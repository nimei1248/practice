现象：
varchar(50) ---> varchar(200)

> ALTER TABLE `t800` MODIFY COLUMN `CLIENT_NAME` varchar(200) DEFAULT NULL;
Query OK, 22121680 rows affected (29 min 37.44 sec)
Records: 22121680  Duplicates: 0  Warnings: 0

> show slave status\G
Last_SQL_Errno: 1677
Last_SQL_Error: Worker 1 failed executing transaction '' at master log mysql-bin.002740, end_log_pos 98568625; Column 13 of table 'db1.t800`' cannot be converted from type 'varchar(150)' to type 'varchar(200)'

$ perror 1677
MySQL error code 1677 (ER_SLAVE_CONVERSION_FAILED): Column %d of table '%-.192s.%-.192s' cannot be converted from type '%-.32s' to type '%-.32s'

2017-09-20 17:21:12 22941 [Warning] Slave SQL: ... The slave coordinator and worker threads are stopped, possibly leaving data in inconsistent state. A restart should restore consistency automatically, although using non-transactional storage for data or info tables or DDL queries could lead to problems. In such cases you have to examine your data (see documentation for details). Error_code: 1756

$ perror 1756
MySQL error code 1756 (ER_MTS_INCONSISTENT_DATA): %s


COLUMN `CLIENT_NAME` 原来是小写，转换后是大写，不知道跟这个是否有关



官方方法：
https://dev.mysql.com/doc/refman/5.7/en/replication-features-differing-tables.html

ALL_LOSSY	
In this mode, type conversions that would mean loss of information are permitted.

This does not imply that non-lossy conversions are permitted, merely that only cases requiring either lossy conversions or no conversion at all are permitted; for example, enabling only this mode permits an INT column to be converted to TINYINT (a lossy conversion), but not a TINYINT column to an INT column (non-lossy). Attempting the latter conversion in this case would cause replication to stop with an error on the slave.

ALL_NON_LOSSY	
This mode permits conversions that do not require truncation or other special handling of the source value; that is, it permits conversions where the target type has a wider range than the source type.

Setting this mode has no bearing on whether lossy conversions are permitted; this is controlled with the ALL_LOSSY mode. If only ALL_NON_LOSSY is set, but not ALL_LOSSY, then attempting a conversion that would result in the loss of data (such as INT to TINYINT, or CHAR(25) to VARCHAR(20)) causes the slave to stop with an error.

ALL_LOSSY,ALL_NON_LOSSY	
When this mode is set, all supported type conversions are permitted, whether or not they are lossy conversions.