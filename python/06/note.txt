返回值的类型:
1.自己返回字符串 return 'hello'
2.返回json(数据交换格式)，很严格，比如key必须是双引号,逗号后面必须有空格
  {
     code:1,
     data:[]
     msg:'密码错误'
  }

In [1]: import json

In [2]: d = {"age":321, "name":123}

In [3]: json.dumps(d)
Out[3]: '{"age": 321, "name": 123}'

3.渲染模板 一定是get 浏览器获取都是get
4.跳转 redirect



作业:
今天作业：上次课的作业,存储换成数据库，加上修改密码功能
作业：用户管理（基于mysql存储）
1.管理员登录（写死账号为admin 密码为pwd，不做也可以）
2.登录之后,看到用户和密码列表(存储在文件中)支持添加，删除的操作,修改密码

上次课作业思路:
1.用户名和密码存储在一个文件中，分号分隔，user:pwd
2.登录页面/login.html，用户名和密码框，提交按钮
3.第2步提交后,跳到/loginaction，验证用户名和密码是否正确，如果验证通过返回到用户列表页面，返回此管理员的用户列表；
  否则,就到login页面；用户列表中显示用户名，删除按钮
4.点击删除按钮,先查找，再确定是否/del?user=xxx，从存储用户和密码的文件中删除
5.点击添加按钮,先查找,再添加,/add?user=xxx&pwd=123
6.点击修改密码按钮,跳转到修改密码页面
7.密码加严，2次md5加密,先对原来密码加密一次，添加一个随机数，再次加密
8.封装，增删改查前都要查，可以把查做成公用模块
9.浏览器---》flask----》文件处理的模块----》文件     单向
10.文件----》文件处理的模块---》flask-----》浏览器   单向
   浏览器点击按钮操作页面，页面是flask监听的路由，每个路由下面对应的是函数/文件处理的模块，文件处理的模块处理文件；
   然后再一层层返回给浏览器上

1.input type=hidden 修改密码时需要前端传递给后端用户名和密码，同时用户名不能显示给客人;
2.显示但不能编辑用户名


flask 官网
flask session 使用方式同dict
session 存在服务器端
cooike 存在客户端浏览器端，客户端删除seesion后，浏览器请求时没有session信息，后端就无法验证浏览器端是否登录
服务器应答时带上session信息，告诉浏览器存储次session信息
浏览器下次请求时带上session信息，服务器端对此session信息进行验证判断是否登录等
它们需要互相配合
http协议的set-cooike

cookie与session原理：
见图

记在服务器端的是session，记在浏览器端是cookie



数据库:
   1.数据库基础增删改查
   2.python操作数据库
      直接执行sql
      orm
         .add()

SQL:

mysql> create database reboot12;
Query OK, 1 row affected (0.00 sec)

mysql> create table woniu_user(user varchar(100), pwd varchar(100));
Query OK, 0 rows affected (0.01 sec)

mysql> desc woniu_user;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| user  | varchar(100) | YES  |     | NULL    |       |
| pwd   | varchar(100) | YES  |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
2 rows in set (0.01 sec)


mysql> insert into woniu_user values('woniu','1234');
Query OK, 1 row affected (0.01 sec)


mysql> insert into woniu_user values('pc','12345');   
Query OK, 1 row affected (0.00 sec)

mysql> select * from woniu_user;                     
+-------+-------+
| user  | pwd   |
+-------+-------+
| woniu | 1234  |
| pc    | 12345 |
+-------+-------+
2 rows in set (0.00 sec)


mysql> update woniu_user set pwd='xxxooo' where user='pc';
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from woniu_user;                          
+-------+--------+
| user  | pwd    |
+-------+--------+
| woniu | 1234   |
| pc    | xxxooo |
+-------+--------+
2 rows in set (0.00 sec)


mysql> insert into woniu_user values('pc2','12345');      
Query OK, 1 row affected (0.01 sec)

mysql> select * from woniu_user;                    
+-------+--------+
| user  | pwd    |
+-------+--------+
| woniu | 1234   |
| pc    | xxxooo |
| pc2   | 12345  |
+-------+--------+
3 rows in set (0.00 sec)

mysql> delete from woniu_user where user='pc2';
Query OK, 1 row affected (0.01 sec)

mysql> select * from woniu_user;               
+-------+--------+
| user  | pwd    |
+-------+--------+
| woniu | 1234   |
| pc    | xxxooo |
+-------+--------+
2 rows in set (0.00 sec)



pip install MySQL-python

In [1]: import MySQLdb

In [2]: 


引入模块：
   import MySQLdb as mysql

链接数据库，返回链接对象
   conn = msql.connect()

获取游标对象,操作sql
   cur = conn.cursor

游标对象执行sql,返回影响的行数
   cur.execute('select * from xxx')

游标对象的fetchall,返回结果
   for user in cur.fetchall():
       print user

练习：添加用户 改成存放到数据库中


事务：sql要么全部执行成功，要么执行全部失败
mysql事务

编程的模型

计算机知识体系:
招式：
   语法 语言 python php go js


内力:
    编程思想
    算法 网络 操作系统 数据库
    算法: 手写冒泡 进阶手写快速排序，了解链表，了解二叉数, 图的遍历

    网络：基于socket手写http服务器
          xx.com/a.jpg
          图解http协议

          ip=>tcp=>(http,ftp,ssh)
          ip=>udp=>dns
          ip：负责寻址
          tcp: 负责数据完整性,有序
          netstring协议

          既然tcp那么可靠，为什么还需要应用层协议？
          主要原因是控制什么时候终止
          tcp没有终止概念
