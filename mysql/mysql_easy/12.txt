                                第12章  存储过程和函数

MySQL 从 5.0 版本开始支持存储过程和函数

12.1 什么是存储过程和函数
1.存储过程和函数是事先经过编译并存储在数据库中的一段 SQL 语句的集合
2.调用存储过程和函数可以简化应用开发人员的很多工作,减少数据在数据库和应用服务器之间的传输,
  对于提高数据处理的效率是有好处的
3.存储过程和函数的区别:
  a.在于函数必须有返回值,而存储过程没有
  b.存储过程的参数可以使用 IN、OUT、INOUT 类型,而函数的参数只能是 IN 类型的
4.如果有函数从其它类型的数据库迁移到 MySQL,那么就可能因此需要将函数改造成存储过程


12.2 存储过程和函数的相关操作
1.在对存储过程或函数进行操作时,需要首先确认用户是否具有相应的权限
  例如,创建存储过程或者函数需要 CREATE ROUTINE 权限,
       修改或者删除存储过程或者函数需要 ALTER ROUTINE 权限,
       执行存储过程或者函数需要 EXECUTE 权限

12.2.1 创建、修改存储过程或者函数
创建、修改存储过程或者函数的语法:
mysql> help create procedure
Name: 'CREATE PROCEDURE'
Description:
Syntax:
CREATE
    [DEFINER = { user | CURRENT_USER }]
    PROCEDURE sp_name ([proc_parameter[,...]])
    [characteristic ...] routine_body

CREATE
    [DEFINER = { user | CURRENT_USER }]
    FUNCTION sp_name ([func_parameter[,...]])
    RETURNS type
    [characteristic ...] routine_body

proc_parameter:
    [ IN | OUT | INOUT ] param_name type

func_parameter:
    param_name type

type:
    Any valid MySQL data type

characteristic:
    COMMENT 'string'
  | LANGUAGE SQL
  | [NOT] DETERMINISTIC
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }

routine_body:
    Valid SQL routine statement


http://dev.mysql.com/doc/refman/5.7/en/create-procedure.html


## 创建存储过程
The following example shows a simple stored procedure that uses an OUT parameter:
下面的示例显示使用out参数的简单存储过程：

mysql> delimiter //
mysql> create procedure simpleproc (out param1 int)
    -> begin
    ->    select count(*) into param1 from t;
    -> end
    -> //
Query OK, 0 rows affected (0.01 sec)

mysql> delimiter ;


调用存储过程的语法:
mysql> call simpleproc(@a);
Query OK, 1 row affected (0.00 sec)

mysql> select @a;
+------+
| @a   |
+------+
|    3 |
+------+
1 row in set (0.00 sec)

mysql> select * from t;
+-----------+
| f         |
+-----------+
|       1.2 |
|       1.3 |
| 1234567.2 |
+-----------+
3 rows in set (0.00 sec)



## 创建函数
The following example function takes a parameter, performs an operation using an SQL function, and returns the result. In this case, it is unnecessary to use delimiter because the function definition contains no internal ; statement delimiters:
下面的示例函数接受一个参数，使用SQL函数执行一个操作，并返回结果。在这种情况下，没有必要使用分隔符，因为函数定义不包含内部；语句分隔符：


mysql> create function hello (s char(20)) returns char(50) deterministic return concat('hello,',s,'!');
Query OK, 0 rows affected (0.00 sec)

mysql> select hello('world');
+----------------+
| hello('world') |
+----------------+
| hello,world!   |
+----------------+
1 row in set (0.00 sec)

mysql> select hello('nimei');
+----------------+
| hello('nimei') |
+----------------+
| hello,nimei!   |
+----------------+
1 row in set (0.00 sec)




1.MySQL 的存储过程和函数中允许包含 DDL 语句,
2.也允许在存储过程中执行提交(Commit, 即确认之前的修改)或者回滚(Rollback,即放弃之前的修改),
3.但是存储过程和函数中不允许执行 LOAD DATA INFILE 语句。
4.存储过程和函数中可以调用其它的过程或者函数

下面创建了一个新的过程 film_in_stock:
mysql> delimiter $$

mysql> create procedure film_in_stock(in p_film_id int, in p_store_id int, out p_film_count int)
    -> reads sql data
    -> begin
    ->    select country_id from country
    ->    where film_id = p_film_id
    ->    and store_id = p_store_id
    ->    and inventory_in_stock(country_id);
    ->    select found_rows() into p_film_count;
    -> end
    -> $$

mysql> create procedure film_in_stock(in p_film_id int, in p_store_id int, out p_film_count int) reads sql data begin    select country_id from country where film_id = p_film_id and store_id = p_store_id and inventory_in_stock(country_id); select found_rows() into p_film_count; end$$
Query OK, 0 rows affected (0.00 sec)


mysql> delimiter ;

------------------
书上例子:
mysql> DELIMITER $$
mysql>
mysql> CREATE PROCEDURE film_in_stock(IN p_film_id INT, IN p_store_id INT, OUT p_film_count)
-> READS SQL DATA -> BEGIN
-> SELECT inventory_id
-> FROM inventory
-> WHERE film_id = p_film_id
-> AND store_id = p_store_id
-> AND inventory_in_stock(inventory_id); ->
-> SELECT FOUND_ROWS() INTO p_film_count; -> END $$
Query OK, 0 rows affected (0.00 sec)
mysql>
mysql> DELIMITER ;


上面是在使用的样例数据库中创建的一个过程,该过程用来检查 film_id 和 store_id 对应的 inventory 是否满足要求,
    并且返回满足要求的 inventory_id 以及满足要求的记录数
通常我们在执行存储过程和函数之前,都会通过“DELIMITER $$”命令将语句的结束符从“;” 修改成其它符号,
    这里使用的是“$$”,这样在存储过程和函数中的“;”就不会被 MySQL 解释成语句的结束而提示错误
    在存储过程或者函数创建完毕,通过“DELIMITER ;”命令再将结束符改回成“;”
可以看到在这个过程中调用了函数 inventory_in_stock(),并且这个过程有两个输入参数和一个输出参数

下面可以通过调用这个过程来看看返回的结果
如果需要检查film_id=2 store_id=2对应的inventory的情况,则首先手工执行过程中的SQL 语句,以查看执行的效果:
mysql> SELECT inventory_id
-> FROM inventory
-> WHERE film_id = 2
-> AND store_id = 2
-> AND inventory_in_stock(inventory_id);
+--------------+ 
| inventory_id | 
+--------------+ 
| 10           | 
| 11           | 
+--------------+
2 rows in set (0.00 sec)


满足条件的记录应该是两条,inventory_id 分别是 10 和 11
如果将这个查询封装在存储过程中调用,那么调用过程的执行情况如下:
mysql> CALL film_in_stock(2,2,@a); 
+--------------+
| inventory_id |
+--------------+
| 10           |
| 11           | 
+--------------+
2 rows in set (0.00 sec)
Query OK, 0 rows affected (0.00 sec)


mysql> select @a;
+------+
| @a   |
+------+
|2     |
+------+
1 row in set (0.00 sec)

可以看到调用存储过程与直接执行 SQL 的效果是相同的,但是存储过程的好处在于处理逻辑都封装在数据库端,
调用者不需要了解中间的处理逻辑,一旦处理逻辑发生变化,只需要修改存储过程即可,而对调用者的程序完全没有影响

另外,和视图的创建语法稍有不同,存储过程和函数的CREATE语法不支持使用CREATE OR REPLACE 对存储过程和函数进行修改,
如果需要对已有的存储过程或者函数进行修改,需要 执行 ALTER 语法


下面对 characteristic 特征值的部分进行简单的说明:
  LANGUAGESQL:
              说明下面过程的BODY是使用SQL语言编写,这条是系统默认的,
              为今后 MySQL 会支持的除 SQL 外的其它语言支持的存储过程而准备

  [NOT]DETERMINISTIC:
                     DETERMINISTIC确定的,即每次输入一样 输出也一样的程序, 
                     NOT DETERMINISTIC 非确定的,默认是非确定的。当前,这个特征值还没有被优化程序使用

  { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }:
              这些特征值提供子程序使用数据的内在信息,这些特征值目前只是提供给服务器,
              并没有根据这些 特征值来约束存储过程实际使用数据的情况

              CONTAINS SQL表示子程序不包含读或写数据的语句
              NO SQL 表示子程序不包含 SQL 语句
              READS SQL DATA 表示子程序包含读数据的语句,但不包含写数据的语句
              MODIFIES SQL DATA 表示子程序包含写数据的语句
              如果这些特征没有明确给定,默认使用的值是 CONTAINS SQL。

  SQL SECURITY { DEFINER | INVOKER }:
              可以用来指定子程序该用创建子程序者的许可来执行,
              还是使用调用者的许可来执行。默认值是 DEFINER。

  COMMENT 'string':
              存储过程或者函数的注释信息。

下面的例子对比了SQL SECURITY特征值的不同,使用root用户创建了两个相似的存储过程,
分别指定使用创建者的权限执行和调用者的权限执行,然后使用一个普通用户调用这两个存 储过程,对比执行的效果:
首先用 root 用户创建以下两个存储过程 film_in_stock_definer 和 film_in_stock_invoker:
mysql> DELIMITER $$
mysql>
mysql> CREATE PROCEDURE film_in_stock_definer(IN p_film_id INT, IN p_store_id INT, OUT
p_film_count INT)
-> SQL SECURITY DEFINER
-> BEGIN
-> SELECT inventory_id
-> FROM inventory
-> WHERE film_id = p_film_id
-> AND store_id = p_store_id
-> AND inventory_in_stock(inventory_id); ->
-> SELECT FOUND_ROWS() INTO p_film_count; -> END $$
Query OK, 0 rows affected (0.00 sec)
mysql>
mysql> CREATE PROCEDURE film_in_stock_invoker(IN p_film_id INT, IN p_store_id INT, OUT p_film_count INT)
-> SQL SECURITY INVOKER -> BEGIN
-> SELECT inventory_id
-> FROM inventory
-> WHERE film_id = p_film_id
-> AND store_id = p_store_id
-> AND inventory_in_stock(inventory_id); ->
-> SELECT FOUND_ROWS() INTO p_film_count; -> END $$
Query OK, 0 rows affected (0.00 sec)
mysql>
mysql> DELIMITER ;
给普通用户 lisa 赋予可以执行存储过程的权限,但是不能查询 inventory 表:
使用 lisa 登录后,直接查询 inventory 表会 示查询被拒绝:
152
 mysql> GRANT EXECUTE ON sakila.* TO 'lisa'@'localhost'; Query OK, 0 rows affected (0.00 sec)
 mysql> select count(*) from inventory;
ERROR 1142 (42000): SELECT command denied to user 'lisa'@'localhost' for table 'inventory'
Linux   www.linuxidc.com
lisa 用户分别调用 film_in_stock_definer 和 film_in_stock_invoker:
mysql> CALL film_in_stock_definer(2,2,@a); +--------------+
| inventory_id |
+--------------+
| 10 |
| 11 | +--------------+
2 rows in set (0.03 sec)
Query OK, 0 rows affected (0.03 sec)
mysql> CALL film_in_stock_invoker(2,2,@a);
ERROR 1142 (42000): SELECT command denied to user 'lisa'@'localhost' for table 'inventory'
从上面的例子可以看出,film_in_stock_definer 是以创建者的权限执行的,因为是 root 用户 创建的,所以可以访问 inventory 表的内容,film_in_stock_invoker 是以调用者的权限执行的, lisa 用户没有访问 inventory 表的权限,所以会 示权限不足。


查看存储过程或者函数的状态:
mysql> show procedure status like 'simpleproc'\G
*************************** 1. row ***************************
                  Db: test
                Name: simpleproc
                Type: PROCEDURE
             Definer: root@localhost
            Modified: 2017-01-23 08:28:31
             Created: 2017-01-23 08:28:31
       Security_type: DEFINER
             Comment:
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: utf8_general_ci
1 row in set (0.01 sec)




查看存储过程或者函数的定义:
mysql> show create procedure simpleproc\G
*************************** 1. row ***************************
           Procedure: simpleproc
            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
    Create Procedure: CREATE DEFINER=`root`@`localhost` PROCEDURE `simpleproc`(out param1 int)
begin
   select count(*) into param1 from t;
end
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: utf8_general_ci
1 row in set (0.00 sec)




---------------------------------------
练习官方文档存储过程及函数:
http://dev.mysql.com/doc/refman/5.7/en/create-procedure.html


mysql> use test
Database changed
mysql> select * from t;
+-----------+
| f         |
+-----------+
|       1.2 |
|       1.3 |
| 1234567.2 |
+-----------+
3 rows in set (0.00 sec)

mysql> select count(*) from t;
+----------+
| count(*) |
+----------+
|        3 |
+----------+
1 row in set (0.00 sec)


mysql> delimiter //
mysql> create procedure shawn (out param1 int)
    -> begin
    ->    select count(*) into param1 from t;
    -> end
    -> //
Query OK, 0 rows affected (0.00 sec)

mysql> delimiter ;


## 有些类似于函数调用方式,存储过程的名字(参数)
## 同时使用@后面可以是任意字符
mysql> call shawn(@a);
Query OK, 1 row affected (0.01 sec)

mysql> select @a;
+------+
| @a   |
+------+
|    3 |
+------+
1 row in set (0.00 sec)


mysql> select count(*) into @a from t;
Query OK, 1 row affected (0.00 sec)



## 测试@
mysql> select count(*) from country;
+----------+
| count(*) |
+----------+
|        2 |
+----------+
1 row in set (0.00 sec)

mysql> select count(*) into @a from country;
Query OK, 1 row affected (0.00 sec)

mysql> select @a;
+------+
| @a   |
+------+
|    2 |
+------+
1 row in set (0.00 sec)

mysql> select count(*) into @xx from country;
Query OK, 1 row affected (0.00 sec)

mysql> select @xx;
+------+
| @xx  |
+------+
|    2 |
+------+
1 row in set (0.00 sec)


2.练习函数
mysql> create function f (s char(20))
    -> returns char(50) deterministic
    -> return concat('hello, ',s,'!');
Query OK, 0 rows affected (0.00 sec)

mysql> select f('world');
+---------------+
| f('world')    |
+---------------+
| hello, world! |
+---------------+
1 row in set (0.00 sec)



3.now()
mysql> create table xx(aa varchar(30));
Query OK, 0 rows affected (0.02 sec)

mysql> insert into xx values(now());
Query OK, 1 row affected (0.00 sec)

mysql> select * from xx;
+---------------------+
| aa                  |
+---------------------+
| 2017-01-25 08:41:31 |
+---------------------+
1 row in set (0.00 sec)



https://github.com/liangxifeng833/my_program/blob/master/mysql/procedure_demo.sql
http://www.jianshu.com/p/1cb06d5eda09
http://database.51cto.com/art/201006/203159.htm


