                                第12章  存储过程和函数

MySQL 从 5.0 版本开始支持存储过程和函数

12.1 什么是存储过程和函数
1.存储过程和函数是事先经过编译并存储在数据库中的一段 SQL 语句的集合
2.调用存储过程和函数可以简化应用开发人员的很多工作,减少数据在数据库和应用服务器之间的传输,
  对于提高数据处理的效率是有好处的
3.存储过程和函数的区别:
  a.在于函数必须有返回值,而存储过程没有
  b.存储过程的参数可以使用 IN、OUT、INOUT 类型,而函数的参数只能是 IN 类型的
4.如果有函数从其它类型的数据库迁移到 MySQL,那么就可能因此需要将函数改造成存储过程


12.2 存储过程和函数的相关操作
1.在对存储过程或函数进行操作时,需要首先确认用户是否具有相应的权限
  例如,创建存储过程或者函数需要 CREATE ROUTINE 权限,
       修改或者删除存储过程或者函数需要 ALTER ROUTINE 权限,
       执行存储过程或者函数需要 EXECUTE 权限

12.2.1 创建、修改存储过程或者函数
创建、修改存储过程或者函数的语法:
mysql> help create procedure
Name: 'CREATE PROCEDURE'
Description:
Syntax:
CREATE
    [DEFINER = { user | CURRENT_USER }]
    PROCEDURE sp_name ([proc_parameter[,...]])
    [characteristic ...] routine_body

CREATE
    [DEFINER = { user | CURRENT_USER }]
    FUNCTION sp_name ([func_parameter[,...]])
    RETURNS type
    [characteristic ...] routine_body

proc_parameter:
    [ IN | OUT | INOUT ] param_name type

func_parameter:
    param_name type

type:
    Any valid MySQL data type

characteristic:
    COMMENT 'string'
  | LANGUAGE SQL
  | [NOT] DETERMINISTIC
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }

routine_body:
    Valid SQL routine statement


http://dev.mysql.com/doc/refman/5.7/en/create-procedure.html


## 创建存储过程
The following example shows a simple stored procedure that uses an OUT parameter:
下面的示例显示使用out参数的简单存储过程：

mysql> delimiter //
mysql> create procedure simpleproc (out param1 int)
    -> begin
    ->    select count(*) into param1 from t;
    -> end
    -> //
Query OK, 0 rows affected (0.01 sec)

mysql> delimiter ;


调用存储过程的语法:
mysql> call simpleproc(@a);
Query OK, 1 row affected (0.00 sec)

mysql> select @a;
+------+
| @a   |
+------+
|    3 |
+------+
1 row in set (0.00 sec)

mysql> select * from t;
+-----------+
| f         |
+-----------+
|       1.2 |
|       1.3 |
| 1234567.2 |
+-----------+
3 rows in set (0.00 sec)



## 创建函数
The following example function takes a parameter, performs an operation using an SQL function, and returns the result. In this case, it is unnecessary to use delimiter because the function definition contains no internal ; statement delimiters:
下面的示例函数接受一个参数，使用SQL函数执行一个操作，并返回结果。在这种情况下，没有必要使用分隔符，因为函数定义不包含内部；语句分隔符：


mysql> create function hello (s char(20)) returns char(50) deterministic return concat('hello,',s,'!');
Query OK, 0 rows affected (0.00 sec)

mysql> select hello('world');
+----------------+
| hello('world') |
+----------------+
| hello,world!   |
+----------------+
1 row in set (0.00 sec)

mysql> select hello('nimei');
+----------------+
| hello('nimei') |
+----------------+
| hello,nimei!   |
+----------------+
1 row in set (0.00 sec)




1.MySQL 的存储过程和函数中允许包含 DDL 语句,
2.也允许在存储过程中执行提交(Commit, 即确认之前的修改)或者回滚(Rollback,即放弃之前的修改),
3.但是存储过程和函数中不允许执行 LOAD DATA INFILE 语句。
4.存储过程和函数中可以调用其它的过程或者函数

下面创建了一个新的过程 film_in_stock:
mysql> delimiter $$

mysql> create procedure film_in_stock(in p_film_id int, in p_store_id int, out p_film_count int)
    -> reads sql data
    -> begin
    ->    select country_id from country
    ->    where film_id = p_film_id
    ->    and store_id = p_store_id
    ->    and inventory_in_stock(country_id);
    ->    select found_rows() into p_film_count;
    -> end
    -> $$

mysql> create procedure film_in_stock(in p_film_id int, in p_store_id int, out p_film_count int) reads sql data begin    select country_id from country where film_id = p_film_id and store_id = p_store_id and inventory_in_stock(country_id); select found_rows() into p_film_count; end$$
Query OK, 0 rows affected (0.00 sec)


mysql> delimiter ;

------------------
书上例子:
mysql> DELIMITER $$
mysql>
mysql> CREATE PROCEDURE film_in_stock(IN p_film_id INT, IN p_store_id INT, OUT p_film_count
-> READS SQL DATA -> BEGIN
-> SELECT inventory_id
-> FROM inventory
-> WHERE film_id = p_film_id
-> AND store_id = p_store_id
-> AND inventory_in_stock(inventory_id); ->
-> SELECT FOUND_ROWS() INTO p_film_count; -> END $$
Query OK, 0 rows affected (0.00 sec)
mysql>
mysql> DELIMITER ;


上面是在使用的样例数据库中创建的一个过程,该过程用来检查 film_id 和 store_id 对应的 inventory 是否满足要求,
    并且返回满足要求的 inventory_id 以及满足要求的记录数
通常我们在执行创建过程和函数之前,都会通过“DELIMITER $$”命令将语句的结束符从“;” 修改成其它符号,
    这里使用的是“$$”,这样在存储过程和函数中的“;”就不会被 MySQL 解释成语句的结束而提示错误
    在存储过程或者函数创建完毕,通过“DELIMITER ;”命令再将结 束符改回成“;”
可以看到在这个过程中调用了函数 inventory_in_stock(),并且这个过程有两个输入参数和一个输出参数

下面可以通过调用这个过程来看看返回的结果。
如果需要检查film_id=2 store_id=2对应的inventory的情况,则首先手工执行过程中的SQL 语句,以查看执行的效果:



查看存储过程或者函数的状态:
mysql> show procedure status like 'simpleproc'\G
*************************** 1. row ***************************
                  Db: test
                Name: simpleproc
                Type: PROCEDURE
             Definer: root@localhost
            Modified: 2017-01-23 08:28:31
             Created: 2017-01-23 08:28:31
       Security_type: DEFINER
             Comment:
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: utf8_general_ci
1 row in set (0.01 sec)




查看存储过程或者函数的定义:
mysql> show create procedure simpleproc\G
*************************** 1. row ***************************
           Procedure: simpleproc
            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
    Create Procedure: CREATE DEFINER=`root`@`localhost` PROCEDURE `simpleproc`(out param1 int)
begin
   select count(*) into param1 from t;
end
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: utf8_general_ci
1 row in set (0.00 sec)


