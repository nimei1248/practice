                                第12章  存储过程和函数

MySQL 从 5.0 版本开始支持存储过程和函数

12.1 什么是存储过程和函数
1.存储过程和函数是事先经过编译并存储在数据库中的一段 SQL 语句的集合
2.调用存储过程和函数可以简化应用开发人员的很多工作,减少数据在数据库和应用服务器之间的传输,
  对于提高数据处理的效率是有好处的
3.存储过程和函数的区别:
  a.在于函数必须有返回值,而存储过程没有
  b.存储过程的参数可以使用 IN、OUT、INOUT 类型,而函数的参数只能是 IN 类型的
4.如果有函数从其它类型的数据库迁移到 MySQL,那么就可能因此需要将函数改造成存储过程


12.2 存储过程和函数的相关操作
1.在对存储过程或函数进行操作时,需要首先确认用户是否具有相应的权限
  例如,创建存储过程或者函数需要 CREATE ROUTINE 权限,
       修改或者删除存储过程或者函数需要 ALTER ROUTINE 权限,
       执行存储过程或者函数需要 EXECUTE 权限

12.2.1 创建、修改存储过程或者函数
创建、修改存储过程或者函数的语法:
mysql> help create procedure
Name: 'CREATE PROCEDURE'
Description:
Syntax:
CREATE
    [DEFINER = { user | CURRENT_USER }]
    PROCEDURE sp_name ([proc_parameter[,...]])
    [characteristic ...] routine_body

CREATE
    [DEFINER = { user | CURRENT_USER }]
    FUNCTION sp_name ([func_parameter[,...]])
    RETURNS type
    [characteristic ...] routine_body

proc_parameter:
    [ IN | OUT | INOUT ] param_name type

func_parameter:
    param_name type

type:
    Any valid MySQL data type

characteristic:
    COMMENT 'string'
  | LANGUAGE SQL
  | [NOT] DETERMINISTIC
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }

routine_body:
    Valid SQL routine statement


http://dev.mysql.com/doc/refman/5.7/en/create-procedure.html


## 创建存储过程
The following example shows a simple stored procedure that uses an OUT parameter:
下面的示例显示使用out参数的简单存储过程：

mysql> delimiter //
mysql> create procedure simpleproc (out param1 int)
    -> begin
    ->    select count(*) into param1 from t;
    -> end
    -> //
Query OK, 0 rows affected (0.01 sec)

mysql> delimiter ;


调用存储过程的语法:
mysql> call simpleproc(@a);
Query OK, 1 row affected (0.00 sec)

mysql> select @a;
+------+
| @a   |
+------+
|    3 |
+------+
1 row in set (0.00 sec)

mysql> select * from t;
+-----------+
| f         |
+-----------+
|       1.2 |
|       1.3 |
| 1234567.2 |
+-----------+
3 rows in set (0.00 sec)



## 创建函数
The following example function takes a parameter, performs an operation using an SQL function, and returns the result. In this case, it is unnecessary to use delimiter because the function definition contains no internal ; statement delimiters:
下面的示例函数接受一个参数，使用SQL函数执行一个操作，并返回结果。在这种情况下，没有必要使用分隔符，因为函数定义不包含内部；语句分隔符：


mysql> create function hello (s char(20)) returns char(50) deterministic return concat('hello,',s,'!');
Query OK, 0 rows affected (0.00 sec)

mysql> select hello('world');
+----------------+
| hello('world') |
+----------------+
| hello,world!   |
+----------------+
1 row in set (0.00 sec)

mysql> select hello('nimei');
+----------------+
| hello('nimei') |
+----------------+
| hello,nimei!   |
+----------------+
1 row in set (0.00 sec)



1.MySQL 的存储过程和函数中允许包含 DDL 语句,
2.也允许在存储过程中执行提交(Commit, 即确认之前的修改)或者回滚(Rollback,即放弃之前的修改),
3.但是存储过程和函数中不允许执行 LOAD DATA INFILE 语句。
4.存储过程和函数中可以调用其它的过程或者函数

下面创建了一个新的过程 film_in_stock:
mysql> delimiter $$

mysql> create procedure film_in_stock(in p_film_id int, in p_store_id int, out p_film_count int)
    -> reads sql data
    -> begin
    ->    select country_id from country
    ->    where film_id = p_film_id
    ->    and store_id = p_store_id
    ->    and inventory_in_stock(country_id);
    ->    select found_rows() into p_film_count;
    -> end
    -> $$

mysql> create procedure film_in_stock(in p_film_id int, in p_store_id int, out p_film_count int) reads sql data begin    select country_id from country where film_id = p_film_id and store_id = p_store_id and inventory_in_stock(country_id); select found_rows() into p_film_count; end$$
Query OK, 0 rows affected (0.00 sec)


mysql> delimiter ;

------------------
书上例子:
mysql> DELIMITER $$
mysql>
mysql> CREATE PROCEDURE film_in_stock(IN p_film_id INT, IN p_store_id INT, OUT p_film_count)
-> READS SQL DATA
-> BEGIN
-> SELECT inventory_id
-> FROM inventory
-> WHERE film_id = p_film_id
-> AND store_id = p_store_id
-> AND inventory_in_stock(inventory_id); 
-> SELECT FOUND_ROWS() INTO p_film_count; 
-> END $$
Query OK, 0 rows affected (0.00 sec)

mysql> DELIMITER ;


上面是在使用的样例数据库中创建的一个过程,该过程用来检查 film_id 和 store_id 对应的 inventory 是否满足要求,
    并且返回满足要求的 inventory_id 以及满足要求的记录数
通常我们在执行存储过程和函数之前,都会通过“DELIMITER $$”命令将语句的结束符从“;” 修改成其它符号,
    这里使用的是“$$”,这样在存储过程和函数中的“;”就不会被 MySQL 解释成语句的结束而提示错误
    在存储过程或者函数创建完毕,通过“DELIMITER ;”命令再将结束符改回成“;”
可以看到在这个过程中调用了函数 inventory_in_stock(),并且这个过程有两个输入参数和一个输出参数

下面可以通过调用这个过程来看看返回的结果
如果需要检查film_id=2 store_id=2对应的inventory的情况,则首先手工执行过程中的SQL 语句,以查看执行的效果:
mysql> SELECT inventory_id
-> FROM inventory
-> WHERE film_id = 2
-> AND store_id = 2
-> AND inventory_in_stock(inventory_id);
+--------------+ 
| inventory_id | 
+--------------+ 
| 10           | 
| 11           | 
+--------------+
2 rows in set (0.00 sec)


满足条件的记录应该是两条,inventory_id 分别是 10 和 11
如果将这个查询封装在存储过程中调用,那么调用过程的执行情况如下:
mysql> CALL film_in_stock(2,2,@a); 
+--------------+
| inventory_id |
+--------------+
| 10           |
| 11           | 
+--------------+
2 rows in set (0.00 sec)
Query OK, 0 rows affected (0.00 sec)


mysql> select @a;
+------+
| @a   |
+------+
|2     |
+------+
1 row in set (0.00 sec)

可以看到调用存储过程与直接执行 SQL 的效果是相同的,但是存储过程的好处在于处理逻辑都封装在数据库端,
调用者不需要了解中间的处理逻辑,一旦处理逻辑发生变化,只需要修改存储过程即可,而对调用者的程序完全没有影响

另外,和视图的创建语法稍有不同,存储过程和函数的CREATE语法不支持使用CREATE OR REPLACE 对存储过程和函数进行修改,
如果需要对已有的存储过程或者函数进行修改,需要 执行 ALTER 语法


下面对 characteristic 特征值的部分进行简单的说明:
  LANGUAGESQL:
              说明下面过程的BODY是使用SQL语言编写,这条是系统默认的,
              为今后 MySQL 会支持的除 SQL 外的其它语言支持的存储过程而准备

  [NOT]DETERMINISTIC:
                     DETERMINISTIC确定的,即每次输入一样 输出也一样的程序, 
                     NOT DETERMINISTIC 非确定的,默认是非确定的。当前,这个特征值还没有被优化程序使用

  { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }:
              这些特征值提供子程序使用数据的内在信息,这些特征值目前只是提供给服务器,
              并没有根据这些特征值来约束存储过程实际使用数据的情况

              CONTAINS SQL 表示子程序不包含读或写数据的语句
              NO SQL 表示子程序不包含 SQL 语句
              READS SQL DATA 表示子程序包含读数据的语句,但不包含写数据的语句
              MODIFIES SQL DATA 表示子程序包含写数据的语句
              如果这些特征没有明确给定,默认使用的值是 CONTAINS SQL。

  SQL SECURITY { DEFINER | INVOKER }:
              可以用来指定子程序调用创建子程序者的许可来执行,
              还是使用调用者的许可来执行。默认值是 DEFINER。

  COMMENT 'string':
              存储过程或者函数的注释信息



下面的例子对比了SQL SECURITY特征值的不同,使用root用户创建了两个相似的存储过程：
1.分别指定使用创建者的权限执行和调用者的权限执行
2.然后使用一个普通用户调用这两个存储过程,对比执行的效果:

首先用 root 用户创建以下两个存储过程 film_in_stock_definer 和 film_in_stock_invoker:
mysql> DELIMITER $$
mysql>
mysql> CREATE PROCEDURE film_in_stock_definer(IN p_film_id INT, IN p_store_id INT, OUT p_film_count INT)
-> SQL SECURITY DEFINER
-> BEGIN
-> SELECT inventory_id
-> FROM inventory
-> WHERE film_id = p_film_id
-> AND store_id = p_store_id
-> AND inventory_in_stock(inventory_id);
-> SELECT FOUND_ROWS() INTO p_film_count;
-> END $$
Query OK, 0 rows affected (0.00 sec)


mysql> CREATE PROCEDURE film_in_stock_invoker(IN p_film_id INT, IN p_store_id INT, OUT p_film_count INT)
-> SQL SECURITY INVOKER
-> BEGIN
-> SELECT inventory_id
-> FROM inventory
-> WHERE film_id = p_film_id
-> AND store_id = p_store_id
-> AND inventory_in_stock(inventory_id);
-> SELECT FOUND_ROWS() INTO p_film_count; 
-> END $$
Query OK, 0 rows affected (0.00 sec)
mysql>
mysql> DELIMITER ;


给普通用户 lisa 赋予可以执行存储过程的权限,但是不能查询 inventory 表:
mysql> GRANT EXECUTE ON sakila.* TO 'lisa'@'localhost';
Query OK, 0 rows affected (0.00 sec)


使用 lisa 登录后,直接查询 inventory 表会 示查询被拒绝:
mysql> select count(*) from inventory;
ERROR 1142 (42000): SELECT command denied to user 'lisa'@'localhost' for table 'inventory'


lisa 用户分别调用存储过程 film_in_stock_definer 和 film_in_stock_invoker:
mysql> CALL film_in_stock_definer(2,2,@a);
+--------------+
| inventory_id |
+--------------+
| 10           |
| 11           | 
+--------------+
2 rows in set (0.03 sec)
Query OK, 0 rows affected (0.03 sec)


mysql> CALL film_in_stock_invoker(2,2,@a);
ERROR 1142 (42000): SELECT command denied to user 'lisa'@'localhost' for table 'inventory'

从上面的例子可以看出:
1.film_in_stock_definer 是以创建者的权限执行的,因为是 root 用户 创建的,所以可以访问 inventory 表的内容
2.film_in_stock_invoker 是以调用者的权限执行的, lisa 用户没有访问 inventory 表的权限,所以会 示权限不足



12.2.2 删除存储过程或者函数
一次只能删除一个存储过程或者函数,删除存储过程或者函数需要有该过程或者函数的 ALTER ROUTINE 权限,具体语法如下:
DROP {PROCEDURE | FUNCTION} [IF EXISTS] sp_name

mysql> help drop
Many help items for your request exist.
To make a more specific request, please type 'help <item>',
where <item> is one of the following
topics:
   ALTER TABLE
   ALTER TABLESPACE
   DEALLOCATE PREPARE
   DROP DATABASE
   DROP EVENT
   DROP FUNCTION
   DROP FUNCTION UDF
   DROP INDEX
   DROP PROCEDURE
   DROP SERVER
   DROP TABLE
   DROP TABLESPACE
   DROP TRIGGER
   DROP USER
   DROP VIEW

mysql> drop procedure shawn;
Query OK, 0 rows affected (0.00 sec)

mysql> drop procedure film_in_stock;
Query OK, 0 rows affected (0.00 sec)



12.2.3 查看存储过程或者函数 
存储过程或者函数创建后,用户可能需要查看存储过程或者函数的状态或者定义等信息,便于了解存储过程或者函数的基本情况。下面将介绍如何查看存储过程或函数相关信息。


mysql> help show
Name: 'SHOW'
Description:
SHOW has many forms that provide information about databases, tables,
columns, or status information about the server. This section describes
those following:

SHOW {BINARY | MASTER} LOGS
SHOW BINLOG EVENTS [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count]
SHOW CHARACTER SET [like_or_where]
SHOW COLLATION [like_or_where]
SHOW [FULL] COLUMNS FROM tbl_name [FROM db_name] [like_or_where]
SHOW CREATE DATABASE db_name
SHOW CREATE EVENT event_name
SHOW CREATE FUNCTION func_name
SHOW CREATE PROCEDURE proc_name
SHOW PROCEDURE CODE proc_name
SHOW PROCEDURE STATUS [like_or_where]


1.查看存储过程或者函数的状态:
mysql> show procedure status like 'simpleproc'\G
*************************** 1. row ***************************
                  Db: test
                Name: simpleproc
                Type: PROCEDURE
             Definer: root@localhost
            Modified: 2017-01-23 08:28:31
             Created: 2017-01-23 08:28:31
       Security_type: DEFINER
             Comment:
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: utf8_general_ci
1 row in set (0.01 sec)



mysql> show procedure status like 'shawn' \G
*************************** 1. row ***************************
                  Db: test
                Name: shawn
                Type: PROCEDURE
             Definer: root@localhost
            Modified: 2017-01-25 08:06:17
             Created: 2017-01-25 08:06:17
       Security_type: DEFINER
             Comment:
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: utf8_general_ci
1 row in set (0.00 sec)




2.查看存储过程或者函数的定义:
mysql> show create procedure simpleproc\G
*************************** 1. row ***************************
           Procedure: simpleproc
            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
    Create Procedure: CREATE DEFINER=`root`@`localhost` PROCEDURE `simpleproc`(out param1 int)
begin
   select count(*) into param1 from t;
end
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: utf8_general_ci
1 row in set (0.00 sec)



mysql> show create procedure shawn \G
*************************** 1. row ***************************
           Procedure: shawn
            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
    Create Procedure: CREATE DEFINER=`root`@`localhost` PROCEDURE `shawn`(out param1 int)
begin
   select count(*) into param1 from t;
end
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: utf8_general_ci
1 row in set (0.01 sec)



3、通过查看information_schema. Routines了解存储过程和函数的信息
除了以上两种方法,我们还可以查看系统表来了解存储过程和函数的相关信息,通过查看 information_schema. Routines 就可以获得存储过程和函数的包括名称、类型、语法、创建人 等信息。
mysql> use information_schema
Database changed
mysql> select * from routines where routine_name='shawn' \G
*************************** 1. row ***************************
           SPECIFIC_NAME: shawn
         ROUTINE_CATALOG: def
          ROUTINE_SCHEMA: test
            ROUTINE_NAME: shawn
            ROUTINE_TYPE: PROCEDURE
               DATA_TYPE:
CHARACTER_MAXIMUM_LENGTH: NULL
  CHARACTER_OCTET_LENGTH: NULL
       NUMERIC_PRECISION: NULL
           NUMERIC_SCALE: NULL
      DATETIME_PRECISION: NULL
      CHARACTER_SET_NAME: NULL
          COLLATION_NAME: NULL
          DTD_IDENTIFIER: NULL
            ROUTINE_BODY: SQL
      ROUTINE_DEFINITION: begin
   select count(*) into param1 from t;
end
           EXTERNAL_NAME: NULL
       EXTERNAL_LANGUAGE: NULL
         PARAMETER_STYLE: SQL
        IS_DETERMINISTIC: NO
         SQL_DATA_ACCESS: CONTAINS SQL
                SQL_PATH: NULL
           SECURITY_TYPE: DEFINER
                 CREATED: 2017-01-25 08:06:17
            LAST_ALTERED: 2017-01-25 08:06:17
                SQL_MODE: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
         ROUTINE_COMMENT:
                 DEFINER: root@localhost
    CHARACTER_SET_CLIENT: utf8
    COLLATION_CONNECTION: utf8_general_ci
      DATABASE_COLLATION: utf8_general_ci
1 row in set (0.00 sec)





---------------------------------------
练习官方文档存储过程及函数:
http://dev.mysql.com/doc/refman/5.7/en/create-procedure.html


mysql> use test
Database changed
mysql> select * from t;
+-----------+
| f         |
+-----------+
|       1.2 |
|       1.3 |
| 1234567.2 |
+-----------+
3 rows in set (0.00 sec)

mysql> select count(*) from t;
+----------+
| count(*) |
+----------+
|        3 |
+----------+
1 row in set (0.00 sec)


mysql> delimiter //
mysql> create procedure shawn (out param1 int)
    -> begin
    ->    select count(*) into param1 from t;
    -> end
    -> //
Query OK, 0 rows affected (0.00 sec)

mysql> delimiter ;


## 有些类似于函数调用方式,存储过程的名字(参数)
## 同时使用@后面可以是任意字符
mysql> call shawn(@a);
Query OK, 1 row affected (0.01 sec)

mysql> select @a;
+------+
| @a   |
+------+
|    3 |
+------+
1 row in set (0.00 sec)


mysql> select count(*) into @a from t;
Query OK, 1 row affected (0.00 sec)



## 测试@
mysql> select count(*) from country;
+----------+
| count(*) |
+----------+
|        2 |
+----------+
1 row in set (0.00 sec)

mysql> select count(*) into @a from country;
Query OK, 1 row affected (0.00 sec)

mysql> select @a;
+------+
| @a   |
+------+
|    2 |
+------+
1 row in set (0.00 sec)

mysql> select count(*) into @xx from country;
Query OK, 1 row affected (0.00 sec)

mysql> select @xx;
+------+
| @xx  |
+------+
|    2 |
+------+
1 row in set (0.00 sec)


2.练习函数
mysql> create function f (s char(20))
    -> returns char(50) deterministic
    -> return concat('hello, ',s,'!');
Query OK, 0 rows affected (0.00 sec)

mysql> select f('world');
+---------------+
| f('world')    |
+---------------+
| hello, world! |
+---------------+
1 row in set (0.00 sec)



3.now()
mysql> create table xx(aa varchar(30));
Query OK, 0 rows affected (0.02 sec)

mysql> insert into xx values(now());
Query OK, 1 row affected (0.00 sec)

mysql> select * from xx;
+---------------------+
| aa                  |
+---------------------+
| 2017-01-25 08:41:31 |
+---------------------+
1 row in set (0.00 sec)



https://github.com/liangxifeng833/my_program/blob/master/mysql/procedure_demo.sql
http://www.jianshu.com/p/1cb06d5eda09
http://database.51cto.com/art/201006/203159.htm




12.2.4 变量的使用
存储过程和函数中可以使用变量,而且在 MySQL 5.1 版本中,变量是不区分大小写的。

1.变量的定义
通过 DECLARE 可以定义一个局部变量,该变量的作用范围只能在 BEGIN...END 块中,可以用在嵌套的块中
变量的定义必须写在复合语句的开头,并且在任何其它语句的前面。
可以一 次声明多个相同类型的变量。如果需要,可以使用 DEFAULT 赋默认值

定义一个变量的语法如下:
mysql> help declare
Many help items for your request exist.
To make a more specific request, please type 'help <item>',
where <item> is one of the following
topics:
   DECLARE CONDITION
   DECLARE CURSOR
   DECLARE HANDLER
   DECLARE VARIABLE

mysql> help declare variable
Name: 'DECLARE VARIABLE'
Description:
Syntax:
DECLARE var_name [, var_name] ... type [DEFAULT value]


http://dev.mysql.com/doc/refman/5.7/en/identifiers.html.
http://dev.mysql.com/doc/refman/5.7/en/declare-local-variable.html

例如,定义一个 DATE 类型的变量,名称是 last_month_start:
DECLARE last_month_start DATE;



2.变量的赋值
变量可以直接赋值,或者通过查询赋值
直接赋值使用 SET,可以赋常量或者赋表达式,具体语法如下:
SET var_name = expr [, var_name = expr] ...

给刚才定义的变量 last_month_start 赋值,具体语法如下:
SET last_month_start = DATE_SUB(CURRENT_DATE(), INTERVAL 1 MONTH);

也可以通过查询将结果赋给变量，这要求查询返回的结果必须只有一行，具体语法如下：
SELECT col_name[,...] INTO var_name[,...] table_expr

通过查询将结果赋值给变量 v_payments:
root@localhost[test] >desc payment_2016;
+--------------+---------------+------+-----+---------+-------+
| Field        | Type          | Null | Key | Default | Extra |
+--------------+---------------+------+-----+---------+-------+
| country_id   | smallint(6)   | YES  | MUL | NULL    |       |
| payment_date | datetime      | YES  |     | NULL    |       |
| amount       | decimal(15,2) | YES  |     | NULL    |       |
+--------------+---------------+------+-----+---------+-------+
3 rows in set (0.00 sec)

root@localhost[test] >delimiter $$
root@localhost[test] >create function get_customer_balance(p_customer_id int, p_effective_date DATETIME)
    -> returns decimal(5,2)
    -> deterministic
    -> reads sql data
    -> begin
    ->    declare v_payments decimal(5,2);
    ->    select ifnull(sum(payment_2016.amount),0) into v_payments from payment_2016
    ->    where payment_2016.payment_date <= p_effective_date
    ->    and payment_2016.country_id = p_customer_id;
    ->    return v_fentfees + v_overfees - v_payments;
    -> END $$
Query OK, 0 rows affected (0.01 sec)

root@localhost[test] >delimiter ;

http://www.cnblogs.com/rooney/archive/2012/03/09/2387732.html
http://blog.csdn.net/jssg_tzw/article/details/39703889



12.2.5 定义条件和处理
条件的定义和处理可以用来定义在处理过程中遇到问题时相应的处理步骤。

1．条件的定义
DECLARE condition_name CONDITION FOR condition_value

condition_value:
      SQLSTATE [VALUE] sqlstate_value
   | mysql_error_code


2．条件的处理
DECLARE handler_type HANDLER FOR condition_value[,...] sp_statement

handler_type:
       CONTINUE
   | EXIT
   | UNDO

condition_value:
     SQLSTATE [VALUE] sqlstate_value
| condition_name
| SQLWARNING
| NOT FOUND
| SQLEXCEPTION
| mysql_error_code


下面将通过两个例子来说明：在向 actor 表中插入记录时，如果没有进行条件的处理，那么
在主键重复的时候会抛出异常并退出，如果对条件进行了处理，那么就不会再抛出异常

（1）当没有进行条件处理时，执行结果如下：
root@localhost[test] >create table actor (actor_id int not null, first_name varchar(20) not null primary key, last_name varchar(20) not null);
Query OK, 0 rows affected (0.03 sec)

root@localhost[test] >desc actor;
+------------+-------------+------+-----+---------+-------+
| Field      | Type        | Null | Key | Default | Extra |
+------------+-------------+------+-----+---------+-------+
| actor_id   | int(11)     | NO   |     | NULL    |       |
| first_name | varchar(20) | NO   | PRI | NULL    |       |
| last_name  | varchar(20) | NO   |     | NULL    |       |
+------------+-------------+------+-----+---------+-------+
3 rows in set (0.01 sec)

root@localhost[test] >show create table actor\G
*************************** 1. row ***************************
       Table: actor
Create Table: CREATE TABLE `actor` (
  `actor_id` int(11) NOT NULL,
  `first_name` varchar(20) COLLATE utf8_bin NOT NULL,
  `last_name` varchar(20) COLLATE utf8_bin NOT NULL,
  PRIMARY KEY (`first_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin
1 row in set (0.00 sec)


root@localhost[test] >delimiter $$
root@localhost[test] >create procedure actor_insert()
    -> begin
    ->    set @x = 1;
    ->    insert into actor values(201,'nimei','201');
    ->    set @x = 2;
    ->    insert into actor values(1,'nimei','1'); 
    ->    set @x = 3;
    ->    insert into actor values(100,'aa','100');
    -> end
    -> $$
Query OK, 0 rows affected (0.01 sec)

root@localhost[test] >delimiter ;


root@localhost[test] >show procedure status like 'actor_insert' \G
*************************** 1. row ***************************
                  Db: test
                Name: actor_insert
                Type: PROCEDURE
             Definer: root@localhost
            Modified: 2017-01-31 18:46:51
             Created: 2017-01-31 18:46:51
       Security_type: DEFINER
             Comment: 
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: utf8_bin
1 row in set (0.01 sec)

root@localhost[test] >show create procedure actor_insert \G              
*************************** 1. row ***************************
           Procedure: actor_insert
            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
    Create Procedure: CREATE DEFINER=`root`@`localhost` PROCEDURE `actor_insert`()
begin
   set @x = 1;
   insert into actor values(201,'nimei','201');
   set @x = 2;
   insert into actor values(1,'nimei','1');
   set @x = 3;
   insert into actor values(100,'aa','100');
end
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: utf8_bin
1 row in set (0.00 sec)


root@localhost[test] >call actor_insert();
ERROR 1062 (23000): Duplicate entry 'nimei' for key 'PRIMARY'
root@localhost[test] >
root@localhost[test] >select @x;
+------+
| @x   |
+------+
|    2 |
+------+
1 row in set (0.00 sec)



root@localhost[test] >truncate actor;
Query OK, 0 rows affected (0.03 sec)

root@localhost[test] >select * from actor;
Empty set (0.00 sec)

root@localhost[test] >delimiter $$
root@localhost[test] >create procedure actor_insert3() begin    set @x = 1;    insert into actor values(201,'nimei','201');    set @x = 2;    insert into actor values(1,'nimei2','1');    set @x = 3;    insert into actor values(100,'nimei','100'); end$$ 
Query OK, 0 rows affected (0.00 sec)

root@localhost[test] >delimiter ;
root@localhost[test] >
root@localhost[test] >call actor_insert3();
ERROR 1062 (23000): Duplicate entry 'nimei' for key 'PRIMARY'
root@localhost[test] >
root@localhost[test] >select @x;
+------+
| @x   |
+------+
|    3 |
+------+
1 row in set (0.00 sec)


从上面的例子可以看出，执行到插入 actor_id=1 or actor_id=3的记录时，会主键重并退出，没有执行到下面其他的语句


（2）当对主键重的异常进行处理时，执行结果如下：



调用条件处理的过程，再遇到主键重的错误时，会按照定义的处理方式进行处理，由于例子
中定义的是 CONTINUE，所以会继续执行下面的语句。
handler_type 现在还只支持 CONTINUE 和 EXIT 两种，CONTINUE 表示继续执行下面的语句，
EXIT 则表示执行终止，UNDO 现在还不支持。
condition_value 的值可以是通过 DECLARE 定义的 condition_name，可以是 SQLSTATE 的值或
者 mysql-error-code 的值或者 SQLWARNING、NOT FOUND、SQLEXCEPTION，这 3 个值是 3 种
定义好的错误类别，分别代表不同的含义。
·SQLWARNING 是对所有以 01 开头的 SQLSTATE 代码的速记。
·NOT FOUND 是对所有以 02 开头的 SQLSTATE 代码的速记。
·SQLEXCEPTION 是对所有没有被 SQLWARNING 或 NOT FOUND 捕获的 SQLSTATE 代码的速记。
因此，上面的例子还可以写成以下几种方式：
--捕获 mysql-error-code：
DECLARE CONTINUE HANDLER FOR 1062 SET @x2 = 1;
--事先定义 condition_name：
DECLARE DuplicateKey CONDITION FOR SQLSTATE '23000';
DECLARE CONTINUE HANDLER FOR DuplicateKey SET @x2 = 1;
--捕获 SQLEXCEPTION
DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET @x2 = 1;
