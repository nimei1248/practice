第3章 MySQL 支持的数据类型


每一个常量、变量、参数都有数据类型，它用来指定一定的存储格式、约束和有效范围

MySQL 提供了多种数据类型，主要包括数值型、字符串类型、日期和时间类型

不同的 MySQL版本支持的数据类型可能会稍有不同， 用户可以通过查询相应版本的帮助文件来获得具体信息
本章将以 MySQL 5.0 为例，详细介绍 MySQL 中的各种数据类型


[3.1 数值类型]
MySQL 支持所有标准 SQL 中的数值类型,其中包括:
严格数值类型(INTEGER、SMALLINT、DECIMAL 和 NUMERIC)
近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION)
并在此基础上做了扩展
扩展后增加了 TINYINT、MEDIUMINT 和 BIGINT 这 3 种长度不同的整型，并增加了 BIT 类型，用来存放位数据


表 3-1 中列出了 MySQL 5.0 中支持的所有数值类型，其中 INT 是 INTEGER 的同名词，DEC 是 DECIMAL 的同名词

MySQL 中的数值类型:
整数类型       字节    最小值				      最大值
TINYINT        1       有符号-128 无符号 0		      有符号 127 无符号 255
SMALLINT       2       有符号-32768 无符号 0		      有符号 32767 无符号 65535
MEDIUMINT      3       有符号-8388608 无符号 0		      有符号 8388607 无符号 1677215
INT、INTEGER   4       有符号-2147483648 无符号 0	      有符号 2147483647 无符号 4294967295
BIGINT         8       有符号-9223372036854775808 无符号 0    有符号 9223372036854775807 无符号 18446744073709551615

整数类型最小值范围和最大值范围举例:
TINYINT  最小值: -128 --- 0  最大值: 127 --- 255


浮点数类型    字节     最小值                     最大值
FLOAT         4        ±1.175494351E-38           ±3.402823466E+38
DOUBLE        8        ±2.2250738585072014E-308   ±1.7976931348623157E+308


定点数类型              字节       描述
DEC(M,D),DECIMAL(M,D)   M+2        最大取值范围与DOUBLE相同,给定DECIMAL的有效取值范围由M和D决定,如,decimal(10,2)


位类型       字节       最小值     最大值
BIT(M)       1～8       BIT(1)     BIT(64)



在整数类型中，按照取值范围和存储方式不同，分为:
tinyint、smallint、mediumint、int、bigint 这 5 个类型

如果超出类型范围的操作，会发生“Out of range”错误提示
为了避免此类问题发生，在选择数据类型时要根据应用的实际情况确定其取值范围，最后根据确定的结果慎重选择数据类型

对于整型数据，MySQL还支持在类型名称后面的小括号内指定显示宽度/长度:
例如, int(5)表示当数值宽度小于 5 位的时候在数字前面填满宽度，如果不显示指定宽度则默认为 int(11)

一般配合 zerofill 使用，顾名思义，zerofill 就是用“0”填充的意思，也就是在数字位数不够的空间用字符“0”填满

以下几个例子分别描述了填充前后的区别:
（1）创建表 t1，有 id1 和 id2 两个字段，指定其数值宽度分别为 int 和 int(5)
mysql> use test1;
Database changed
mysql> create table t1(id1 int, id2 int(5)); 
Query OK, 0 rows affected (0.03 sec)


当int不是无符号unsigned时,int默认长度为11
mysql> desc t1;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| id1   | int(11) | YES  |     | NULL    |       |
| id2   | int(5)  | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
2 rows in set (0.00 sec)


（2）在 id1 和 id2 中都插入数值 1，可以发现格式没有异常:
mysql> insert into t1 values(1,1);
Query OK, 1 row affected (0.00 sec)

mysql> select * from t1;
+------+------+
| id1  | id2  |
+------+------+
|    1 |    1 |
+------+------+
1 row in set (0.00 sec)


（3）分别修改 id1 和 id2 的字段类型，加入 zerofill 参数：
当int是无符号unsigned时,int默认长度为10, zerofill用于填充0

mysql> alter table t1 modify id1 int zerofill;
Query OK, 1 row affected (0.03 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql> alter table t1 modify id2 int(5) zerofill;
Query OK, 1 row affected (0.03 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql> desc t1;
+-------+---------------------------+------+-----+---------+-------+
| Field | Type                      | Null | Key | Default | Extra |
+-------+---------------------------+------+-----+---------+-------+
| id1   | int(10) unsigned zerofill | YES  |     | NULL    |       |
| id2   | int(5) unsigned zerofill  | YES  |     | NULL    |       |
+-------+---------------------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

mysql> select * from t1;
+------------+-------+
| id1        | id2   |
+------------+-------+
| 0000000001 | 00001 |
+------------+-------+
1 row in set (0.00 sec)


可以发现，在数值前面用字符“0”填充了剩余的宽度

大家可能会有所疑问，设置了宽度限制后，如果插入大于宽度限制的值，会不会截断或者插不进去报错？
答案是肯定的：不会对插入的数据有任何影响，还是按照类型的实际精度进行保存
这时，宽度格式实际已经没有意义，左边不会再填充任何的“0”字符

下面在表t1的字段 id1 中插入数值 1，id2 中插入数值 1111111，位数为 7，大于 id2 的显示位数 5，再观察一下测试结果：
ql> desc t1;
+-------+---------------------------+------+-----+---------+-------+
| Field | Type                      | Null | Key | Default | Extra |
+-------+---------------------------+------+-----+---------+-------+
| id1   | int(10) unsigned zerofill | YES  |     | NULL    |       |
| id2   | int(5) unsigned zerofill  | YES  |     | NULL    |       |
+-------+---------------------------+------+-----+---------+-------+
2 rows in set (0.01 sec)

mysql> select * from t1;
+------------+-------+
| id1        | id2   |
+------------+-------+
| 0000000001 | 00001 |
+------------+-------+
1 row in set (0.00 sec)

mysql> insert into t1 values(1,1111111);
Query OK, 1 row affected (0.01 sec)

mysql> select * from t1;                
+------------+---------+
| id1        | id2     |
+------------+---------+
| 0000000001 |   00001 |
| 0000000001 | 1111111 |
+------------+---------+
2 rows in set (0.00 sec)

很显然，如上面所说，id2 中显示了正确的数值，并没有受宽度限制影响


整数类型之UNSIGNED（无符号）正数:
1.所有的整数类型都有一个可选属性 UNSIGNED（无符号）,
  如果需要在字段里面保存非负数或者需要较大的上限值时，可以用此选项

2.它的取值范围是正常值的下限取 0，上限取原值的 2 倍,
  例如，tinyint 有符号范围是-128～+127，而无符号范围是 0～255

3.有符号和无符号怎么理解？
  正负数,有符号是负数,无符号是正数,如果为正数是无法插入负数数据:
        mysql> select * from t1;
	+------------+---------+
	| id1        | id2     |
	+------------+---------+
	| 0000000001 |   00001 |
	| 0000000001 | 1111111 |
	+------------+---------+
	2 rows in set (0.00 sec)

	mysql> insert into t1 values(-123,-111);
	ERROR 1264 (22003): Out of range value for column 'id1' at row 1
	mysql> 
	mysql> insert into t1 values(-1,-111);  
	ERROR 1264 (22003): Out of range value for column 'id1' at row 1
	mysql> 
	mysql> insert into t1 values(-1,-1);  
	ERROR 1264 (22003): Out of range value for column 'id1' at row 1


4.如果一个列指定为 zerofill，则 MySQL 自动为该列添加 UNSIGNED 属性


整数类型属性之： AUTO_INCREMENT
1.在需要产生唯一标识符或顺序值时，可利用此属性, 这个属性只用于整数类型
2.AUTO_INCREMENT值一般从 1 开始， 每行增加 1
3.在插入 NULL 到一个 AUTO_INCREMENT 列时，MySQL 插入一个比该列中当前最大值大 1 的值
4.一个表中最多只能有一个 AUTO_INCREMENT列
5.对于任何想要使用 AUTO_INCREMENT的列，应该定义为 NOT NULL，并定义为 PRIMARY KEY 或定义为 UNIQUE键

例如，可按下列任何一种方式定义AUTO_INCREMENT列:
ql> use test1;
Database changed
mysql> create table A1(ID INT AUTO_INCREMENT NOT NULL PRIMARY KEY);
Query OK, 0 rows affected (0.03 sec)

mysql> create table A2(ID INT AUTO_INCREMENT NOT NULL, PRIMARY KEY(ID));
Query OK, 0 rows affected (0.02 sec)

mysql> create table A3(ID INT AUTO_INCREMENT NOT NULL, UNIQUE(ID));      
Query OK, 0 rows affected (0.02 sec)

mysql> desc A1;
+-------+---------+------+-----+---------+----------------+
| Field | Type    | Null | Key | Default | Extra          |
+-------+---------+------+-----+---------+----------------+
| ID    | int(11) | NO   | PRI | NULL    | auto_increment |
+-------+---------+------+-----+---------+----------------+
1 row in set (0.00 sec)

mysql> desc A2;
+-------+---------+------+-----+---------+----------------+
| Field | Type    | Null | Key | Default | Extra          |
+-------+---------+------+-----+---------+----------------+
| ID    | int(11) | NO   | PRI | NULL    | auto_increment |
+-------+---------+------+-----+---------+----------------+
1 row in set (0.00 sec)

mysql> desc A3;
+-------+---------+------+-----+---------+----------------+
| Field | Type    | Null | Key | Default | Extra          |
+-------+---------+------+-----+---------+----------------+
| ID    | int(11) | NO   | PRI | NULL    | auto_increment |
+-------+---------+------+-----+---------+----------------+
1 row in set (0.00 sec)



3.在插入 NULL 到一个 AUTO_INCREMENT 列时，MySQL 插入一个比该列中当前最大值大 1 的值
mysql> use test1;
mysql> desc A1; 
+-------+---------+------+-----+---------+----------------+
| Field | Type    | Null | Key | Default | Extra          |
+-------+---------+------+-----+---------+----------------+
| ID    | int(11) | NO   | PRI | NULL    | auto_increment |
+-------+---------+------+-----+---------+----------------+
1 row in set (0.00 sec)

mysql> insert into A1 values();
Query OK, 1 row affected (0.01 sec)

mysql> select * from A1;
+----+
| ID |
+----+
|  1 |
+----+
1 row in set (0.00 sec)

mysql> insert into A1 values();
Query OK, 1 row affected (0.00 sec)

mysql> select * from A1;       
+----+
| ID |
+----+
|  1 |
|  2 |
+----+
2 rows in set (0.00 sec)

mysql> insert into A1 values(null);
Query OK, 1 row affected (0.01 sec)

mysql> select * from A1;           
+----+
| ID |
+----+
|  1 |
|  2 |
|  3 |
+----+
3 rows in set (0.00 sec)


mysql> insert into A1 values(10);  
Query OK, 1 row affected (0.02 sec)

mysql> select * from A1;         
+----+
| ID |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
| 10 |
+----+
5 rows in set (0.00 sec)

mysql> insert into A1 values(null);
Query OK, 1 row affected (0.02 sec)

mysql> select * from A1;           
+----+
| ID |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
| 10 |
| 11 |
+----+
6 rows in set (0.00 sec)



对于小数的表示，MySQL 分为两种方式：浮点数和定点数:
1.浮点数包括 float（单精度）和 double（双精度）

2.定点数则只有 decimal 一种表示
  定点数在 MySQL 内部以字符串形式存放，比浮点数更精确，适合用来表示货币等精度高的数据

3.浮点数和定点数都可以用类型名称后加“(M,D)”的方式来进行表示:
  "(M,D)"表示该值一共显示 M 位数字（整数位+小数位）,其中 D 位位于小数点后面，M 和 D 又称为精度和标度

  例如，定义为 float(7,4)的一个列可以显示为-999.9999
        MySQL保存值时进行四舍五入，因此如果在 float(7,4)列内插入 999.00009，近似结果是 999.0001

4.值得注意的是，浮点数后面跟“(M,D)”的用法是非标准用法，如果要用于数据库的迁移，则最好不要这么使用

5.float 和 double 在不指定精度时，默认会按照实际的精度（由实际的硬件和操作系统决定）来显示

6.decimal 在不指定精度时，默认的整数位为 10，默认的小数位为 0


7.下面通过一个例子来比较 float、double 和 decimal 三者之间的不同:
（1） 创建测试表， 分别将 id1、 id2、 id3 字段设置为 float(5,2)、 double(5,2)、 decimal(5,2)
mysql> use test1;
Database changed

mysql> drop table t1;
Query OK, 0 rows affected (0.01 sec)

mysql> create table t1 (id1 float(5,2) default NULL, id2 double(5,2) default NULL, id3 decimal(5,2) default NUll);
Query OK, 0 rows affected (0.02 sec)

mysql> desc t1;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id1   | float(5,2)   | YES  |     | NULL    |       |
| id2   | double(5,2)  | YES  |     | NULL    |       |
| id3   | decimal(5,2) | YES  |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
3 rows in set (0.00 sec)


（2）往 id1、id2 和 id3 这 3 个字段中插入数据 1.23
mysql> insert into t1 values(1.23, 1.23, 1.23);
Query OK, 1 row affected (0.01 sec)

mysql> select * from t1;
+------+------+------+
| id1  | id2  | id3  |
+------+------+------+
| 1.23 | 1.23 | 1.23 |
+------+------+------+
1 row in set (0.01 sec)

可以发现，数据都正确地插入了表 t1


（3）再向 id1 和 id2 字段中插入数据 1.234，而 id3 字段中仍然插入 1.23
mysql> insert into t1 values(1.234, 1.234, 1.23);
Query OK, 1 row affected (0.00 sec)

mysql> select * from t1;                         
+------+------+------+
| id1  | id2  | id3  |
+------+------+------+
| 1.23 | 1.23 | 1.23 |
| 1.23 | 1.23 | 1.23 |
+------+------+------+
2 rows in set (0.00 sec)

可以发现,id1、 id2、 id3 都插入了表 t1, 但是 id1 和 id2 由于标度的限制，舍去了最后一位，数据变为了1.23


（4）同时向 id1、id2、id3 字段中都插入数据 1.234
mysql> insert into t1 values(1.234, 1.234, 1.234);
Query OK, 1 row affected, 1 warning (0.01 sec)

mysql> show warnings;
+-------+------+------------------------------------------+
| Level | Code | Message                                  |
+-------+------+------------------------------------------+
| Note  | 1265 | Data truncated for column 'id3' at row 1 |
+-------+------+------------------------------------------+
1 row in set (0.00 sec)

mysql> select * from t1;
+------+------+------+
| id1  | id2  | id3  |
+------+------+------+
| 1.23 | 1.23 | 1.23 |
| 1.23 | 1.23 | 1.23 |
| 1.23 | 1.23 | 1.23 |
+------+------+------+
3 rows in set (0.00 sec)

此时发现，虽然数据都插入进去，但是系统出现了一个 warning，报告 id3 被截断
如果是在传统的 SQLMode（第 16 章将会详细介绍 SQLMode）下，这条记录是无法插入的


（5）将 id1、id2、id3 字段的精度和标度全部去掉，再次插入数据 1.23
mysql> desc t1;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id1   | float(5,2)   | YES  |     | NULL    |       |
| id2   | double(5,2)  | YES  |     | NULL    |       |
| id3   | decimal(5,2) | YES  |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
3 rows in set (0.00 sec)

mysql> alter table t1 modify id1 float;
Query OK, 0 rows affected (0.00 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> alter table t1 modify id2 double;
Query OK, 0 rows affected (0.00 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> alter table t1 modify id3 decimal;
Query OK, 3 rows affected, 3 warnings (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 3

mysql> desc t1;
+-------+---------------+------+-----+---------+-------+
| Field | Type          | Null | Key | Default | Extra |
+-------+---------------+------+-----+---------+-------+
| id1   | float         | YES  |     | NULL    |       |
| id2   | double        | YES  |     | NULL    |       |
| id3   | decimal(10,0) | YES  |     | NULL    |       |
+-------+---------------+------+-----+---------+-------+
3 rows in set (0.00 sec)


再次插入数据测试:
mysql> select * from t1;
+------+------+------+
| id1  | id2  | id3  |
+------+------+------+
| 1.23 | 1.23 |    1 |
| 1.23 | 1.23 |    1 |
| 1.23 | 1.23 |    1 |
+------+------+------+
3 rows in set (0.00 sec)

mysql> insert into t1 values(1.234, 1.234, 1.234);
Query OK, 1 row affected, 1 warning (0.00 sec)

mysql> show warnings;
+-------+------+------------------------------------------+
| Level | Code | Message                                  |
+-------+------+------------------------------------------+
| Note  | 1265 | Data truncated for column 'id3' at row 1 |
+-------+------+------------------------------------------+
1 row in set (0.00 sec)

mysql> select * from t1;                          
+-------+-------+------+
| id1   | id2   | id3  |
+-------+-------+------+
|  1.23 |  1.23 |    1 |
|  1.23 |  1.23 |    1 |
|  1.23 |  1.23 |    1 |
| 1.234 | 1.234 |    1 |
+-------+-------+------+
4 rows in set (0.00 sec)


这个时候，可以发现 id1、id2 字段中可以正常插入数据，而 id3 字段的小数位被截断。
上面这个例子验证了上面提到的浮点数如果不写精度和标度，则会按照实际精度值显示，
如果有精度和标度，则会自动将四舍五入后的结果插入，系统不会报错；

定点数如果不写精度和标度，则按照默认值 decimal(10,0)来进行操作，并且如果数据超越了精度和标度值，系统则会报错


对于 BIT（位）类型，用于存放位字段值，BIT(M)可以用来存放多位二进制数，M 范围从 1～64，如果不写则默认为 1 位
对于位字段，直接使用 SELECT 命令将不会看到结果，可以用bin()（显示为二进制格式）或者 hex()（显示为十六进制格式）函数进行读取

下面的例子中，对测试表 t2 中的 bit 类型字段 id 做 insert 和 select 操作，这里重点观察一下
select 的结果：

mysql> use test1;
Database changed

mysql> create table t2(id bit); 
Query OK, 0 rows affected (0.03 sec)

mysql> desc t2;
+-------+--------+------+-----+---------+-------+
| Field | Type   | Null | Key | Default | Extra |
+-------+--------+------+-----+---------+-------+
| id    | bit(1) | YES  |     | NULL    |       |
+-------+--------+------+-----+---------+-------+
1 row in set (0.00 sec)

mysql> insert into t2 values(1); 
Query OK, 1 row affected (0.01 sec)

mysql> select * from t2;
+------+
| id   |
+------+
|     |
+------+
1 row in set (0.00 sec)


可以发现,直接 select * 结果为 NULL。改用 bin()和 hex()函数再试试:


mysql> select bin(id),hex(id) from t2; 
+---------+---------+
| bin(id) | hex(id) |
+---------+---------+
| 1       | 1       |
+---------+---------+
1 row in set (0.00 sec)


结果可以正常显示为二进制数字和十六进制数字

数据插入 bit 类型字段时,首先将数据转换为二进制,如果位数允许,将成功插入;如果位数小于 实际定义的位数,则插入失败

下面的例子中,在 t2 表插入数字 2,因为它的二进制码是 “10”,而 id 的定义是 bit(1),将无法进行插入:
mysql> desc t2;
+-------+--------+------+-----+---------+-------+
| Field | Type   | Null | Key | Default | Extra |
+-------+--------+------+-----+---------+-------+
| id    | bit(1) | YES  |     | NULL    |       |
+-------+--------+------+-----+---------+-------+
1 row in set (0.00 sec)

mysql> insert into t2 values(2);
ERROR 1406 (22001): Data too long for column 'id' at row 1
mysql> 
mysql> show warnings;
+-------+------+----------------------------------------+
| Level | Code | Message                                |
+-------+------+----------------------------------------+
| Error | 1406 | Data too long for column 'id' at row 1 |
+-------+------+----------------------------------------+
1 row in set (0.00 sec)

将 ID 定义修改为 bit(2)后,重新插入,插入成功:

mysql> alter table t2 modify id bit(2);
Query OK, 1 row affected (0.03 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql> desc t2;
+-------+--------+------+-----+---------+-------+
| Field | Type   | Null | Key | Default | Extra |
+-------+--------+------+-----+---------+-------+
| id    | bit(2) | YES  |     | NULL    |       |
+-------+--------+------+-----+---------+-------+
1 row in set (0.00 sec)

mysql> insert into t2 values(2);
Query OK, 1 row affected (0.01 sec)

mysql> select bin(id) from t2;
+---------+
| bin(id) |
+---------+
| 1       |
| 10      |
+---------+
2 rows in set (0.00 sec)


mysql> select bin(id),hex(id) from t2;
+---------+---------+
| bin(id) | hex(id) |
+---------+---------+
| 1       | 1       |
| 10      | 2       |
+---------+---------+
2 rows in set (0.01 sec)




3.2 日期时间类型
MySQL 中有多种数据类型可以用于日期和时间的表示,不同的版本可能有所差异
表 3-2 中 列出了 MySQL 5.0 中所支持的日期和时间类型

表 3-2 MySQL中的日期和时间类型:
日期和时间类型  字节   最小值                  最大值
DATE            4      1000-01-01              9999-12-31
DATETIME        8      1000-01-01 00:00:00     9999-12-31 23:59:59
TIMESTAMP       4      19700101080001          2038 年的某个时刻
TIME            3      -838:59:59              838:59:59
YEAR            1      1901                    2155


这些数据类型的主要区别如下:
 1.如果要用来表示年月日,通常用 DATE 来表示
 2.如果要用来表示年月日时分秒,通常用 DATETIME 表示
 3.如果只用来表示时分秒,通常用 TIME 来表示
 4.如果需要经常插入或者更新日期为当前系统时间,则通常使用 TIMESTAMP 来表示
      1) TIMESTAMP 值返回后显示为"YYYY-MM-DD HH:MM:SS"格式的字符串,显示宽度固定为19 个字符
      2) 如果想要获得数字值,应在 TIMESTAMP 列添加+0
 5.如果只是表示年份,可以用 YEAR 来表示,它比 DATE 占用更少的空间
      1) YEAR 有 2 位或 4 位格式的年。默认是 4 位格式
      2) 在 4 位格式中,允许的值是 1901~2155 和 0000
      3) 在 2 位格式中,允许的值是 70~69,表示从 1970~2069 年
      4) MySQL 以 YYYY 格式显示 YEAR值


从表 3-2 中可以看出:
    每种日期时间类型都有一个有效值范围,如果超出这个范围,在默认的 SQLMode 下,系统会进行错误提示,并将以零值来进行存储


不同日期类型零值的 表示如表 3-3 所示:
    MySQL 中日期和时间类型的零值表示:
    数据类型     零值表示
    DATETIME     0000-00-00 00:00:00
    DATE         0000-00-00
    TIMESTAMP    00000000000000
    TIME         00:00:00
    YEAR         0000


DATE、TIME 和 DATETIME 是最常使用的 3 种日期类型,以下例子在 3 种类型字段插入了相同的日期值,来看看它们的显示结果:

首先创建表 t,字段分别为 date、time、datetime 三种日期类型:
mysql> use test1;
Database changed

mysql> create table t(d date, t time, dt datetime);
Query OK, 0 rows affected (0.02 sec)

mysql> desc t;
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| d     | date     | YES  |     | NULL    |       |
| t     | time     | YES  |     | NULL    |       |
| dt    | datetime | YES  |     | NULL    |       |
+-------+----------+------+-----+---------+-------+
3 rows in set (0.00 sec)

用 now()函数插入当前日期:
mysql> insert into t values(now(), now(), now());
Query OK, 1 row affected, 1 warning (0.00 sec)


查看结果:
mysql> select * from t;
+------------+----------+---------------------+
| d          | t        | dt                  |
+------------+----------+---------------------+
| 2017-01-05 | 21:27:52 | 2017-01-05 21:27:52 |
+------------+----------+---------------------+
1 row in set (0.00 sec)


显而易见,DATETIME是DATE和TIME的组合,用户可以根据不同的需要,来选择不同的日期或时间类型以满足不同的应用。

TIMESTAMP也用来表示日期,但是和DATETIME有所不同,后面的章节中会专门介绍。下例对TIMESTAMP类型的特性进行一些测试。
创建测试表t,字段id1为TIMESTAMP类型:
mysql> use test1;
Database changed

mysql> alter table t rename time_test;
Query OK, 0 rows affected (0.01 sec)

mysql> show tables;
+-----------------+
| Tables_in_test1 |
+-----------------+
| A1              |
| A2              |
| A3              |
| dept            |
| emp             |
| t1              |
| t2              |
| time_test       |
+-----------------+
8 rows in set (0.00 sec)

mysql> create table t(id1 timestamp);
Query OK, 0 rows affected (0.03 sec)

mysql> desc t;
+-------+-----------+------+-----+---------+-------+
| Field | Type      | Null | Key | Default | Extra |
+-------+-----------+------+-----+---------+-------+
| id1   | timestamp | YES  |     | NULL    |       |
+-------+-----------+------+-----+---------+-------+
1 row in set (0.00 sec)

可以发现,系统给 timestamp 自动创建了默认值 CURRENT_TIMESTAMP(系统日期)
Percona 5.7: 经测试发现Default默认值为NULL


插入一个 NULL 值试试:
mysql> insert into t values(null);
Query OK, 1 row affected (0.00 sec)

mysql> select * from t;
+------+
| id1  |
+------+
| NULL |
+------+
1 row in set (0.01 sec)


果然,t中正确插入了系统日期。注意,MySQL只给表中的第一个TIMESTAMP字段设置 默认值为系统日期,如果有第二个TIMESTAMP类型,则默认值设置为0值,测试如下:
经测试发现都是null

mysql> alter table t add id2 timestamp;
Query OK, 0 rows affected (0.06 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> desc t;
+-------+-----------+------+-----+---------+-------+
| Field | Type      | Null | Key | Default | Extra |
+-------+-----------+------+-----+---------+-------+
| id1   | timestamp | YES  |     | NULL    |       |
| id2   | timestamp | YES  |     | NULL    |       |
+-------+-----------+------+-----+---------+-------+
2 rows in set (0.00 sec)


即使将timestamp类型的默认值改成CURRENT_TIMESTAMP,插入值时，也会显示null
mysql> alter table t modify id1 timestamp default current_timestamp;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> alter table t modify id2 timestamp default current_timestamp;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> desc t;
+-------+-----------+------+-----+-------------------+-------+
| Field | Type      | Null | Key | Default           | Extra |
+-------+-----------+------+-----+-------------------+-------+
| id1   | timestamp | YES  |     | CURRENT_TIMESTAMP |       |
| id2   | timestamp | YES  |     | CURRENT_TIMESTAMP |       |
+-------+-----------+------+-----+-------------------+-------+
2 rows in set (0.00 sec)

mysql> insert into t values(null,null);
Query OK, 1 row affected (0.01 sec)

mysql> select * from t;
+------+------+
| id1  | id2  |
+------+------+
| NULL | NULL |
+------+------+
1 row in set (0.00 sec)

mysql> insert into t values('2017-01-01 10:10:10',null);
Query OK, 1 row affected (0.01 sec)

mysql> select * from t;
+---------------------+------+
| id1                 | id2  |
+---------------------+------+
| NULL                | NULL |
| 2017-01-01 10:10:10 | NULL |
+---------------------+------+
2 rows in set (0.01 sec)




TIMESTAMP还有一个重要特点,就是和时区相关:
当插入日期时,会先转换为本地时区后存放;而从数据库里面取出时,也同样需要将日期转换为本地时区后显示
这样,两个不同时区的用户看到的同一个日期可能是不一样的

下面的例子演示了这个差别:

(1)创建表t8,包含字段id1(TIMESTAMP)和id2(DATETIME),设置id2的目的是为了和id1做对比:
mysql> use test1;
Database changed
mysql> create table t8(id1 timestamp not null default current_timestamp, id2 datetime default null);
Query OK, 0 rows affected (0.02 sec)

mysql> desc t8;
+-------+-----------+------+-----+-------------------+-------+
| Field | Type      | Null | Key | Default           | Extra |
+-------+-----------+------+-----+-------------------+-------+
| id1   | timestamp | NO   |     | CURRENT_TIMESTAMP |       |
| id2   | datetime  | YES  |     | NULL              |       |
+-------+-----------+------+-----+-------------------+-------+
2 rows in set (0.00 sec)


(2)查看当前时区:
mysql> show variables like 'time_zone';
+---------------+--------+
| Variable_name | Value  |
+---------------+--------+
| time_zone     | SYSTEM |
+---------------+--------+
1 row in set (0.00 sec)

mysql> system date
Thu Jan  5 22:27:04 HKT 2017
可以发现,时区的值为“SYSTEM”,这个值默认是和主机的时区值一致的,因为我们本机是HK时区, 这里的“SYSTEM”实际是东八区(+8:00)


(3)用 now()函数插入当前日期:
mysql> insert into t8 values(now(),now());
Query OK, 1 row affected (0.01 sec)

mysql> select * from t8;
+---------------------+---------------------+
| id1                 | id2                 |
+---------------------+---------------------+
| 2017-01-05 22:25:19 | 2017-01-05 22:25:19 |
+---------------------+---------------------+
1 row in set (0.00 sec)

结果显示 id1 和 id2 的值完全相同
因为TIMESTAMP 值返回后显示为"YYYY-MM-DD HH:MM:SS"格式的字符串，显示宽度固定为 19 个字符
如果想要获得数字值，应在 TIMESTAMP 列添加+0


(4)修改mysql数据库的时区为东九区,再次查看表中日期:
mysql> set time_zone='+9:00';          
Query OK, 0 rows affected (0.00 sec)

mysql> show variables like 'time_zone';
+---------------+--------+
| Variable_name | Value  |
+---------------+--------+
| time_zone     | +09:00 |
+---------------+--------+
1 row in set (0.01 sec)

mysql> select * from t8;               
+---------------------+---------------------+
| id1                 | id2                 |
+---------------------+---------------------+
| 2017-01-05 23:25:19 | 2017-01-05 22:25:19 |
+---------------------+---------------------+
1 row in set (0.00 sec)


结果中可以发现,id1 的值比 id2 的值快了 1 个小时,也就是说,东九区的人看到的“2017-01-05 23:25:19”是当地时区的实际日期,也就是东八区的“2017-01-05 22:25:19”,如果还是以 “2017-01-05 22:25:19”理解时间必然导致误差


TIMESTAMP的取值范围为19700101080001到2038年的某一天,因此它不适合存放比较久远的日期,下面简单测试一些这个范围:
mysql> use test1;
Database changed
mysql> desc t;
+-------+-----------+------+-----+-------------------+-------+
| Field | Type      | Null | Key | Default           | Extra |
+-------+-----------+------+-----+-------------------+-------+
| id1   | timestamp | YES  |     | CURRENT_TIMESTAMP |       |
| id2   | timestamp | YES  |     | CURRENT_TIMESTAMP |       |
+-------+-----------+------+-----+-------------------+-------+
2 rows in set (0.00 sec)


mysql> alter table t drop id2;  
Query OK, 0 rows affected (0.06 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> desc t;
+-------+-----------+------+-----+-------------------+-------+
| Field | Type      | Null | Key | Default           | Extra |
+-------+-----------+------+-----+-------------------+-------+
| id1   | timestamp | YES  |     | CURRENT_TIMESTAMP |       |
+-------+-----------+------+-----+-------------------+-------+
1 row in set (0.00 sec)

mysql> delete from t;
Query OK, 3 rows affected (0.01 sec)

mysql> select * from t;
Empty set (0.00 sec)

mysql> insert into t values(19700101080001);
Query OK, 1 row affected (0.01 sec)

mysql> select * from t;                     
+---------------------+
| id1                 |
+---------------------+
| 1970-01-01 08:00:01 |
+---------------------+
1 row in set (0.00 sec)


mysql> insert into t values(19700101080000);
ERROR 1292 (22007): Incorrect datetime value: '19700101080000' for column 'id1' at row 1

mysql> show warnings;                       
+-------+------+----------------------------------------------------------------------+
| Level | Code | Message                                                              |
+-------+------+----------------------------------------------------------------------+
| Error | 1292 | Incorrect datetime value: '19700101080000' for column 'id1' at row 1 |
+-------+------+----------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> select * from t;
+---------------------+
| id1                 |
+---------------------+
| 1970-01-01 08:00:01 |
+---------------------+
1 row in set (0.00 sec)


其中 19700101080000 超出了 tm 的下限,系统出现警告提示。查询一下,发现插入值变成 了 0 值。
经测试发现，提示时间日期不正确，数据无法插入到表



再来测试一下 TIMESTAMP 的上限值:
mysql> insert into t values('2038-01-19 11:14:07');
Query OK, 1 row affected (0.01 sec)

mysql> select * from t;                            
+---------------------+
| id1                 |
+---------------------+
| 1970-01-01 08:00:01 |
| 1970-01-01 08:00:01 |
| 1970-01-01 08:00:02 |
| 2038-01-19 11:14:07 |
+---------------------+
4 rows in set (0.00 sec)

mysql> insert into t values('2038-01-19 11:14:08');
ERROR 1292 (22007): Incorrect datetime value: '2038-01-19 11:14:08' for column 'id1' at row 1


从上面例子可以看出,TIMESTAMP和DATETIME的表示方法非常类似,区别主要有以下几点:
 1.TIMESTAMP支持的时间范围较小,其取值范围从19700101080001到2038年的某个时间,而DATETIME是从1000-01-01 00:00:00到9999-12-31 23:59:59,范围更大

 2.表中的第一个TIMESTAMP列自动设置为系统时间。如果在一个TIMESTAMP列中插入 NULL,则该列值将自动设置为当前的日期和时间。在插入或更新一行但不明确给 TIMESTAMP列赋值时也会自动设置该列的值为当前的日期和时间,当插入的值超出 取值范围时,MySQL认为该值溢出,使用“0000-00-00 00:00:00”进行填补
    经测试有些不对

  3.TIMESTAMP的插入和查询都受当地时区的影响,更能反应出实际的日期。而 DATETIME则只能反应出插入时当地的时区,其它时区的人查看数据必然会有误差的

  4.TIMESTAMP的属性受MySQL版本和服务器SQLMode的影响很大,本章都是以MySQL 5.0为例进行介绍,在不同的版本下可以参考相应的MySQL帮助文档


YEAR 类型主要用来表示年份,当应用只需要记录年份时,用 YEAR 比 DATE 将更节省空间:
下面的例子在表 t 中定义了一个 YEAR 类型字段,并插入一条记录:
mysql> use test1;
Database changed
mysql> create table y(y year);
Query OK, 0 rows affected (0.02 sec)

mysql> desc y;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| y     | year(4) | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
1 row in set (0.00 sec)

mysql> insert into y values(2100);
Query OK, 1 row affected (0.00 sec)

mysql> select * from y;
+------+
| y    |
+------+
| 2100 |
+------+
1 row in set (0.00 sec)


MySQL 以 YYYY 格式检索和显示 YEAR 值,范围是1901~2155。当使用两位字符串表示 年份时,其范围为“00”到“99”
 1.“00”到“69”范围的值被转换为 2000~2069 范围的 YEAR 值
  2.“70”到“99”范围的值被转换为 1970~1999 范围的 YEAR 值。


细心的读者可能发现,在上面的例子中,日期类型的插入格式有很多,包括整数(如 2100)、字符串(如 2038-01-19 11:14:08)、函数(如 NOW())等,大家可能会感到疑惑,到底什么样的格式才能够正确地插入到对应的日期字段中呢?

下面以 DATETIME 为例进行介绍:
 1.YYYY-MM-DD HH:MM:SS 或 YY-MM-DD HH:MM:SS 格式的字符串
    a.允许“不严格” 语法:任何标点符都可以用做日期部分或时间部分之间的间割符:
    例如,“98-12-31 11:30:45”、“98.12.31 11+30+45”、“98/12/31 11*30*45”和“98@12@31 11^30^45” 是等价的
    
    b.对于包括日期部分间割符的字符串值,如果日和月的值小于10,不需要指定两位数
    “1979-6-9”与“1979-06-09”是相同的

  2.同样,对于包括时间部分间割符的字符串值,如果时、分和秒的值小于10,不需要指定两位数:
    “1979-10-30 1:2:3”与“1979-10-30 01:02:03”相同

 3.YYYYMMDDHHMMSS 或 YYMMDDHHMMSS 格式的没有间割符的字符串,假定字符串对于日期类型是有意义的
    例如,“19970523091528”和“970523091528”被解 释为“1997-05-23 09:15:28”,
    但“971122129015”是不合法的(它有一个没有意义的分钟部分),将变为“0000-00-00 00:00:00”

 4.YYYYMMDDHHMMSS 或 YYMMDDHHMMSS 格式的数字,假定数字对于日期类型是有意义的:
    例如,19830905132800 和 830905132800 被解释为“1983-09-05 13:28:00”

    数字值应为 6、8、12 或者 14 位长
    如果一个数值是 8 或 14 位长,则假定为 YYYYMMDD 或 YYYYMMDDHHMMSS 格式,前 4 位数表示年
    如果数字 是 6 或 12 位长,则假定为 YYMMDD 或 YYMMDDHHMMSS 格式,前 2 位数表示年
    其它数字 被解释为仿佛用零填充到了最近的长度
 
  5.函数返回的结果,其值适合 DATETIME、DATE 或者 TIMESTAMP 上下文
    例如 NOW() 或 CURRENT_DATE
    对于其它数据类型,其使用原则与上面的内容类似,限于篇幅,这里就不再赘述


最后通过一个例子,说明如何采用不同的格式将日期“2007-9-3 12:10:10”插入到 DATETIME 列中:
mysql> use test1;
Database changed
mysql> create table t6(dt datetime);
Query OK, 0 rows affected (0.02 sec)

mysql> desc t6;
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| dt    | datetime | YES  |     | NULL    |       |
+-------+----------+------+-----+---------+-------+
1 row in set (0.00 sec)

mysql> insert into t6 values('2017-01-05 23:59:59');
Query OK, 1 row affected (0.00 sec)

mysql> insert into t6 values('2017/01/05 23+59+59');  
Query OK, 1 row affected (0.01 sec)

mysql> insert into t6 values('20170105235959');     
Query OK, 1 row affected (0.00 sec)

mysql> insert into t6 values(20170105235959);  
Query OK, 1 row affected (0.00 sec)

mysql> select * from t6;
+---------------------+
| dt                  |
+---------------------+
| 2017-01-05 23:59:59 |
| 2017-01-05 23:59:59 |
| 2017-01-05 23:59:59 |
| 2017-01-05 23:59:59 |
+---------------------+
4 rows in set (0.00 sec)



3.3 字符串类型

MySQL 中提供了多种对字符数据的存储类型，不同的版本可能有所差异
以 5.0 版本为例，MySQL 包括了 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等多种字符串类型

表 3-4 中详细列出了这些字符类型的比较

MySQL 中的字符类型:
字符串类型   字节    描述及存储需求
CHAR（M）    M       M 为 0～255 之间的整数
VARCHAR（M） M       为 0～65535 之间的整数，值的长度+1 个字节
TINYBLOB             允许长度 0～255 字节，值的长度+1 个字节
BLOB                 允许长度 0～65535 字节，值的长度+2 个字节
MEDIUMBLOB           允许长度 0～167772150 字节，值的长度+3 个字节
LONGBLOB             允许长度 0～4294967295 字节，值的长度+4 个字节
TINYTEXT             允许长度 0～255 字节，值的长度+2 个字节
TEXT                 允许长度 0～65535 字节，值的长度+2 个字节
MEDIUMTEXT           允许长度 0～167772150 字节，值的长度+3 个字节
LONGTEXT             允许长度 0～4294967295 字节，值的长度+4 个字节
BINARY（M） M        允许长度 0～M 个字节的定长字节字符串
VARBINARY（M）       允许长度 0～M 个字节的变长字节字符串，值的长度+1 个字节


下面将分别对这些字符串类型做详细的介绍
3.3.1 CHAR 和 VARCHAR 类型
1.CHAR 和 VARCHAR 很类似，都用来保存 MySQL 中较短的字符串
2.二者的主要区别在于存储方式的不同:
  a.CHAR 列的长度固定为创建表时声明的长度，长度可以为从 0～255 的任何值
  b.VARCHAR 列中的值为可变长字符串，长度可以指定为 0～255 （5.0.3 以前） 或者 65535 （5.0.3以后）之间的值
  c.在检索的时候，CHAR 列删除了尾部的空格，而 VARCHAR 则保留这些空格


下面的例子中通过给表 vc 中的 VARCHAR(4)和 char(4)字段插入相同的字符串来描述这个区别:
（1）创建测试表 vc，并定义两个字段 v VARCHAR(4)和 c CHAR(4)
mysql> use test1;
Database changed
mysql> create table vc(v VARCHAR(4), c CHAR(4));
Query OK, 0 rows affected (0.02 sec)

mysql> desc vc;
+-------+------------+------+-----+---------+-------+
| Field | Type       | Null | Key | Default | Extra |
+-------+------------+------+-----+---------+-------+
| v     | varchar(4) | YES  |     | NULL    |       |
| c     | char(4)    | YES  |     | NULL    |       |
+-------+------------+------+-----+---------+-------+
2 rows in set (0.02 sec)

（2）v 和 c 列中同时插入字符串"ab":
mysql> insert into vc values('ab  ', 'ab  ');
Query OK, 1 row affected (0.00 sec)

mysql> select * from vc;
+------+------+
| v    | c    |
+------+------+
| ab   | ab   |
+------+------+
1 row in set (0.01 sec)

（3）显示查询结果：
mysql> select length(v),length(c) from vc; 
+-----------+-----------+
| length(v) | length(c) |
+-----------+-----------+
|         4 |         2 |
+-----------+-----------+
1 row in set (0.00 sec)

可以发现，c 字段的 length 只有 2。给两个字段分别追加一个“+”字符看得更清楚：
mysql> select concat(v, '+'),concat(c, '+') from vc;
+----------------+----------------+
| concat(v, '+') | concat(c, '+') |
+----------------+----------------+
| ab  +          | ab+            |
+----------------+----------------+
1 row in set (0.00 sec)


mysql> insert into vc values('ab  ', 'ab  ');
Query OK, 1 row affected (0.01 sec)

mysql> SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;
+---------------------+---------------------+
| CONCAT('(', v, ')') | CONCAT('(', c, ')') |
+---------------------+---------------------+
| (ab)                | (ab)                |
| (ab  )              | (ab)                |
+---------------------+---------------------+
2 rows in set (0.00 sec)

显然，CHAR 列最后的空格在做操作时都已经被删除，而 VARCHAR 依然保留空格



3.3.2 BINARY 和 VARBINARY 类型
BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不包含非二进制字符串
在下面的例子中，对表 t 中的 binary 字段 c 插入一个字符，研究一下这个字符到底是怎么样存储的?
（1）创建测试表 t，字段为 c BINARY(3)
mysql> use test1;
Database changed
mysql> drop table t;
Query OK, 0 rows affected (0.02 sec)

mysql> create table t(c BINARY(3));
Query OK, 0 rows affected (0.03 sec)

mysql> desc t;
+-------+-----------+------+-----+---------+-------+
| Field | Type      | Null | Key | Default | Extra |
+-------+-----------+------+-----+---------+-------+
| c     | binary(3) | YES  |     | NULL    |       |
+-------+-----------+------+-----+---------+-------+
1 row in set (0.01 sec)

mysql> insert into t values('b');
Query OK, 1 row affected (0.00 sec)

（2）往 c 字段中插入字符“a”:
mysql> insert into t SET c='a';  
Query OK, 1 row affected (0.01 sec)

mysql> select * from t;
+------+
| c    |
+------+
| b    |
| a    |
+------+
2 rows in set (0.00 sec)

（3）分别用以下几种模式来查看 c 列的内容：
mysql> select *,hex(c),c='a',c='a\0',c='a\0\0' from t; 
+------+--------+-------+---------+-----------+
| c    | hex(c) | c='a' | c='a\0' | c='a\0\0' |
+------+--------+-------+---------+-----------+
| b    | 620000 |     0 |       0 |         0 |
| a    | 610000 |     0 |       0 |         1 |
+------+--------+-------+---------+-----------+
2 rows in set (0.00 sec)


mysql> select *,bin(c),c='a',c='a\0',c='a\0\0' from t;
+------+--------+-------+---------+-----------+
| c    | bin(c) | c='a' | c='a\0' | c='a\0\0' |
+------+--------+-------+---------+-----------+
| b    | 0      |     0 |       0 |         0 |
| a    | 0      |     0 |       0 |         1 |
+------+--------+-------+---------+-----------+
2 rows in set (0.01 sec)

可以发现，当保存 BINARY 值时，在值的最后通过填充“0x00” （零字节）以达到指定的字段定义长度
从上例中看出，对于一个 BINARY(3)列，当插入时'a'变为'a\0\0'



3.3.3 ENUM 类型
ENUM 中文名称叫枚举类型，它的值范围需要在创建表时通过枚举方式显式指定:
     1.对 1～255 个成员的枚举需要 1 个字节存储
     2.对于 255～65535 个成员，需要 2 个字节存储
     3.最多允许有 65535 个成员

下面往测试表 t 中插入几条记录来看看 ENUM 的使用方法
（1）创建测试表 t，定义 gender 字段为枚举类型，成员为'M'和'F'：
mysql> use test1;
Database changed
mysql> drop table t;
Query OK, 0 rows affected (0.02 sec)

mysql> create table t(gender enum('M','F'));
Query OK, 0 rows affected (0.02 sec)

mysql> desc t;
+--------+---------------+------+-----+---------+-------+
| Field  | Type          | Null | Key | Default | Extra |
+--------+---------------+------+-----+---------+-------+
| gender | enum('M','F') | YES  |     | NULL    |       |
+--------+---------------+------+-----+---------+-------+
1 row in set (0.00 sec)

mysql> insert into t values('M'),('1'),('f'),(NULL);
ERROR 1265 (01000): Data truncated for column 'gender' at row 3
mysql> select * from t;
Empty set (0.00 sec)

mysql> insert into t values('f'),(NULL);      
ERROR 1265 (01000): Data truncated for column 'gender' at row 1

从上面的例子中，可以看出 ENUM 类型是忽略大小写的，对'M'、'f'在存储的时候将它们都转
成了大写，还可以看出对于插入不在 ENUM 指定范围内的值时，并没有返回警告，而是插
入了 enum('M','F')的第一值'M'，这点用户在使用时要特别注意。
另外，ENUM 类型只允许从值集合中选取单个值，而不能一次取多个值

经验证5.7版本报错如上


https://dev.mysql.com/doc/refman/5.7/en/enum.html

mysql> use test1;
Database changed
mysql> create table shirts(name VARCHAR(40), size ENUM('x-small','small','medium','large','x-large'));
Query OK, 0 rows affected (0.02 sec)

mysql> desc shirts;
+-------+----------------------------------------------------+------+-----+---------+-------+
| Field | Type                                               | Null | Key | Default | Extra |
+-------+----------------------------------------------------+------+-----+---------+-------+
| name  | varchar(40)                                        | YES  |     | NULL    |       |
| size  | enum('x-small','small','medium','large','x-large') | YES  |     | NULL    |       |
+-------+----------------------------------------------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

mysql> insert into shirts(name,size) values('dress shirt','large'),('t-shirt','medium'),('polo shirt','small');
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> select * from shirts;
+-------------+--------+
| name        | size   |
+-------------+--------+
| dress shirt | large  |
| t-shirt     | medium |
| polo shirt  | small  |
+-------------+--------+
3 rows in set (0.00 sec)

mysql> update shirts set size='large' where size='small';
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from shirts;                             
+-------------+--------+
| name        | size   |
+-------------+--------+
| dress shirt | large  |
| t-shirt     | medium |
| polo shirt  | large  |
+-------------+--------+
3 rows in set (0.00 sec)



3.3.4 SET 类型

Set 和 ENUM 类型非常类似，也是一个字符串对象，里面可以包含 0～64 个成员
根据成员的不同，存储上也有所不同:
 1～8 成员的集合，占 1 个字节
 9～16 成员的集合，占 2 个字节
 17～24 成员的集合，占 3 个字节
 25～32 成员的集合，占 4 个字节
 33～64 成员的集合，占 8 个字节

Set 和 ENUM 除了存储之外，最主要的区别在于 Set 类型一次可以选取多个成员，而 ENUM则只能选一个
下面的例子在表 t 中插入了多组不同的成员：
mysql> use test1;
Database changed
mysql> create table t7(col set ('a','b','c','d'));
Query OK, 0 rows affected (0.03 sec)

mysql> desc t7;
+-------+----------------------+------+-----+---------+-------+
| Field | Type                 | Null | Key | Default | Extra |
+-------+----------------------+------+-----+---------+-------+
| col   | set('a','b','c','d') | YES  |     | NULL    |       |
+-------+----------------------+------+-----+---------+-------+
1 row in set (0.00 sec)

mysql> insert into t values('a,b'),('a,d,a'),('a,b'),('a,c'),('a');
ERROR 1265 (01000): Data truncated for column 'gender' at row 1
mysql> insert into t values('a,b'),('a,d,a'),('a,b'),('a,c');      
ERROR 1265 (01000): Data truncated for column 'gender' at row 1


SET 类型可以从允许值集合中选择任意 1 个或多个元素进行组合，所以对于输入的值只要是在允许值的组合范围内，
都可以正确地注入到 SET 类型的列中
对于超出允许值范围的值例,如（'a,d,f'）将不允许注入到上面例子中设置的 SET 类型列中
对于（'a,d,a'）这样包含重复成员的集合将只取一次，写入后的结果为“a,d” ，这一点请注意


https://dev.mysql.com/doc/refman/5.7/en/set.html

mysql> use test1;
Database changed
mysql> create table myset(col SET('a','b','c','d'));
Query OK, 0 rows affected (0.02 sec)

mysql> desc myset;
+-------+----------------------+------+-----+---------+-------+
| Field | Type                 | Null | Key | Default | Extra |
+-------+----------------------+------+-----+---------+-------+
| col   | set('a','b','c','d') | YES  |     | NULL    |       |
+-------+----------------------+------+-----+---------+-------+
1 row in set (0.00 sec)

mysql> insert into myset(col) values('a,d'), ('d,a'), ('a,d,a'), ('a,d,d'), ('d,a,d');
Query OK, 5 rows affected (0.00 sec)
Records: 5  Duplicates: 0  Warnings: 0

mysql> select * from myset;
+------+
| col  |
+------+
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
+------+
5 rows in set (0.01 sec)

3.4 小结

本章主要介绍了 MySQL 支持的各种数据类型，并通过多个实例对它们的使用方法做了详细的说明
学完本章后，读者可以对每种数据类型的用途、物理存储、表示范围等有一个概要的了解
这样在面对具体应用时，就可以根据相应的特点来选择合适的数据类型，使得我们能够争取在满足应用的基础上，
用较小的存储代价换来较高的数据库性能
