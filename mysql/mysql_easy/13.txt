                                           第13章 触发器

1.MySQL 从 5.0.2 版本开始支持触发器的功能
2.触发器是与表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合
3.触发器的这种特性可以协助应用在数据库端确保数据的完整性
本章将详细介绍 MySQL 中触发器的使用方法


13.1 创建触发器
创建触发器的语法如下：
CREATE TRIGGER trigger_name trigger_time trigger_event
       ON tbl_name FOR EACH ROW trigger_stmt

注意：触发器只能创建在永久表（Permanent Table）上，不能对临时表（Temporary Table）创建触发器

1.其中 trigger_time 是触发器的触发时间，可以是 BEFORE 或者 AFTER:
     BEFORE 的含义指在检查约束前触发，而 AFTER 是在检查约束后触发

2.而 trigger_event 就是触发器的触发事件，可以是 INSERT、UPDATE、DELETE

3.对同一个表相同触发时间的相同触发事件，只能定义一个触发器
     例如，对某个表的不同字段的 AFTER 更新触发器：
           1.在使用 Oracle 数据库的时候，可以定义成两个不同的 UPDATE 触发器，更新不同的字段时触发单独的触发器
           2.在 MYSQL 数据库中，只能定义成一个触发器，在触发器中通过判断更新的字段进行对应的处理

4.使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其它的数据库是相似的

5.现在触发器还只支持行级触发的，不支持语句级触发


在样例数据库中，为 film 表创建了 AFTER INSERT 的触发器，具体如下：

1.创建表film
root@localhost[test] >create table film(film_id int not null, title varchar(20) not null, description varchar(20) not null);      
Query OK, 0 rows affected (0.02 sec)

root@localhost[test] >desc film;
+-------------+-------------+------+-----+---------+-------+
| Field       | Type        | Null | Key | Default | Extra |
+-------------+-------------+------+-----+---------+-------+
| film_id     | int(11)     | NO   |     | NULL    |       |
| title       | varchar(20) | NO   |     | NULL    |       |
| description | varchar(20) | NO   |     | NULL    |       |
+-------------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)


2.创建表film_text
root@localhost[test] >create table file_text(film_id int not null, title varchar(20) not null, description varchar(20) not null);
Query OK, 0 rows affected (0.02 sec)

root@localhost[test] >alter table file_text rename film_text;
Query OK, 0 rows affected (0.01 sec)

root@localhost[test] >show create table film_text\G
*************************** 1. row ***************************
       Table: film_text
Create Table: CREATE TABLE `film_text` (
  `film_id` int(11) NOT NULL,
  `title` varchar(20) COLLATE utf8_bin NOT NULL,
  `description` varchar(20) COLLATE utf8_bin NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin
1 row in set (0.00 sec)

root@localhost[test] >desc film_text;
+-------------+-------------+------+-----+---------+-------+
| Field       | Type        | Null | Key | Default | Extra |
+-------------+-------------+------+-----+---------+-------+
| film_id     | int(11)     | NO   |     | NULL    |       |
| title       | varchar(20) | NO   |     | NULL    |       |
| description | varchar(20) | NO   |     | NULL    |       |
+-------------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)


3.创建film表的触发器ins_film2
root@localhost[test] >delimiter $$
root@localhost[test] >create trigger ins_film2
    -> after insert on film for each row
    -> begin
    ->     insert into film_text values(new.film_id, new.title, new.description);
    -> end
    -> $$
Query OK, 0 rows affected (0.00 sec)

root@localhost[test] >delimiter ;


4.查看触发器
root@localhost[test] >show triggers\G
*************************** 1. row ***************************
             Trigger: ins_film2
               Event: INSERT
               Table: film
           Statement: begin
    insert into film_text values(new.film_id, new.title, new.description);
end
              Timing: AFTER
             Created: 2017-02-01 14:22:35.36
            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
             Definer: root@localhost
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: utf8_bin
1 row in set (0.00 sec)



5.插入 film 表记录的时候，会向 film_text 表中也插入相应的记录:
root@localhost[test] >insert into film values(1001,'RESIDENT EVIL','Picking up alice');                                         
Query OK, 1 row affected (0.00 sec)

root@localhost[test] >select * from film;
+---------+---------------+------------------+
| film_id | title         | description      |
+---------+---------------+------------------+
|    1001 | RESIDENT EVIL | Picking up alice |
+---------+---------------+------------------+
1 row in set (0.00 sec)

root@localhost[test] >select * from film_text;
+---------+---------------+------------------+
| film_id | title         | description      |
+---------+---------------+------------------+
|    1001 | RESIDENT EVIL | Picking up alice |
+---------+---------------+------------------+
1 row in set (0.00 sec)



对于 INSERT INOT…ON DUPLICATE KEY UPDATE…语句来说，触发触发器的顺序可能会造成疑惑
下面对 film 表分别创建了 BEFROE INSERT、AFTER INSERT、BEFORE UPDATE、AFTER UPDATE
触发器，然后插入记录，观察触发器的触发情况:

--创建 BEFROE INSERT、AFTER INSERT、BEFORE UPDATE、AFTER UPDATE 触发器：
film表见上一个例子

root@localhost[test] >create table tridemo(id int auto_increment, note varchar(20), primary key (id));
Query OK, 0 rows affected (0.02 sec)

root@localhost[test] >desc tridemo;
+-------+-------------+------+-----+---------+----------------+
| Field | Type        | Null | Key | Default | Extra          |
+-------+-------------+------+-----+---------+----------------+
| id    | int(11)     | NO   | PRI | NULL    | auto_increment |
| note  | varchar(20) | YES  |     | NULL    |                |
+-------+-------------+------+-----+---------+----------------+
2 rows in set (0.00 sec)

root@localhost[test] >delimiter $$
root@localhost[test] >create trigger ins_film_bef
    -> before insert on film for each row
    -> begin
    ->     insert into tridemo(note) values('before insert');
    -> end
    -> $$
Query OK, 0 rows affected (0.01 sec)


root@localhost[test] >create trigger ins_film_aft
    -> after insert on film for each row
    -> begin
    ->     insert into tridemo(note) values('after insert');
    -> end
    -> $$
Query OK, 0 rows affected (0.01 sec)


root@localhost[test] >create trigger upd_film_bef
    -> before update on film for each row
    -> begin
    ->     insert into tridemo(note) values('before update');
    -> end
    -> $$
Query OK, 0 rows affected (0.01 sec)

root@localhost[test] >create trigger upd_film_aft
    -> after update on film for each row
    -> begin
    ->     insert into tridemo(note) values('after update');
    -> end
    -> $$
Query OK, 0 rows affected (0.01 sec)


root@localhost[test] >delimiter ;



--插入记录已经存在的情况：
root@localhost[test] >select * from film;
+---------+---------------+------------------+
| film_id | title         | description      |
+---------+---------------+------------------+
|    1001 | RESIDENT EVIL | Picking up alice |
+---------+---------------+------------------+
1 row in set (0.00 sec)

root@localhost[test] >insert into film values(1001, 'RESIDENT EVIL', 'Picking up alice');
Query OK, 1 row affected (0.00 sec)

root@localhost[test] >select * from film;
+---------+---------------+------------------+
| film_id | title         | description      |
+---------+---------------+------------------+
|    1001 | RESIDENT EVIL | Picking up alice |
|    1001 | RESIDENT EVIL | Picking up alice |
+---------+---------------+------------------+
2 rows in set (0.00 sec)

root@localhost[test] >select * from tridemo;
+----+---------------+
| id | note          |
+----+---------------+
|  1 | before insert |
|  2 | after insert  |
+----+---------------+
2 rows in set (0.00 sec)

root@localhost[test] >delete from tridemo;  
Query OK, 2 rows affected (0.05 sec)

root@localhost[test] >insert into film values(1001, 'RESIDENT EVIL', 'Picking up alice') on duplicate key update title='RESIDENT EVIL';
Query OK, 1 row affected (0.01 sec)

root@localhost[test] >select * from tridemo;
+----+---------------+
| id | note          |
+----+---------------+
|  7 | before insert |
|  8 | after insert  |
+----+---------------+
2 rows in set (0.00 sec)



--插入新记录的情况：
root@localhost[test] >delete from tridemo;        
Query OK, 2 rows affected (0.01 sec)

root@localhost[test] >select * from tridemo;
Empty set (0.00 sec)

root@localhost[test] >insert into film values(1002, 'xxx RESIDENT EVIL', 'xxx Picking up alice'); 
Query OK, 1 row affected (0.01 sec)

root@localhost[test] >select * from tridemo;
+----+---------------+
| id | note          |
+----+---------------+
|  3 | before insert |
|  4 | after insert  |
+----+---------------+
2 rows in set (0.00 sec)


root@localhost[test] >delete from tridemo;
Query OK, 0 rows affected (0.00 sec)

root@localhost[test] >insert into film values(1003, 'RESIDENT EVIL4', 'Picking up alice4') on duplicate key update title='RESIDENT EVIL4';
Query OK, 1 row affected (0.01 sec)

root@localhost[test] >select * from tridemo;      
+----+---------------+
| id | note          |
+----+---------------+
|  9 | before insert |
| 10 | after insert  |
+----+---------------+
2 rows in set (0.00 sec)


--update更新操作
root@localhost[test] >select * from film;
+---------+-------------------+----------------------+
| film_id | title             | description          |
+---------+-------------------+----------------------+
|    1001 | RESIDENT EVIL     | Picking up alice     |
|    1001 | RESIDENT EVIL     | Picking up alice     |
|    1002 | xxx RESIDENT EVIL | xxx Picking up alice |
|    1001 | RESIDENT EVIL     | Picking up alice     |
|    1001 | RESIDENT EVIL     | Picking up alice     |
|    1003 | RESIDENT EVIL4    | Picking up alice4    |
+---------+-------------------+----------------------+
6 rows in set (0.00 sec)

root@localhost[test] >update film set title='xxxxxx' where film_id=1003;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

root@localhost[test] >select * from tridemo;                            
+----+---------------+
| id | note          |
+----+---------------+
| 11 | before update |
| 12 | after update  |
+----+---------------+
2 rows in set (0.00 sec)



从上面的例子可以知道，对于有重复记录，需要进行 UPDATE 操作的 INSERT，触发器触发的
顺序是 BEFORE INSERT、BEFORE UPDATE、AFTER UPDATE；
对于没有重复记录的 INSERT，就是简单的执行 INSERT 操作，触发器触发的顺序是 BEFORE INSERT、AFTER INSERT
对于那些实际执行 UPDATE 操作的记录，仍然会执行 BEFORE INSERT 触发器的内容，在设计触发器的时候一定要考虑这种情况，
    避免错误地触发了触发器


经过测试结论似乎与书上有些不同





13.3 查看触发器
可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息，但是因为不能查询指
定的触发器，所以每次都返回所有的触发器的信息，使用起来不是很方便，具体语法如下：

root@localhost[test] >show triggers\G
*************************** 3. row ***************************
             Trigger: ins_film_aft
               Event: INSERT
               Table: film
           Statement: begin
    insert into tridemo(note) values('after insert');
end
              Timing: AFTER
             Created: 2017-02-01 14:41:22.40
            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
             Definer: root@localhost
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: utf8_bin
*************************** 4. row ***************************
             Trigger: upd_film_bef
               Event: UPDATE
               Table: film
           Statement: begin
    insert into tridemo(note) values('before update');
end
              Timing: BEFORE
             Created: 2017-02-01 14:43:05.76
            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
             Definer: root@localhost
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: utf8_bin
*************************** 5. row ***************************
             Trigger: upd_film_aft
               Event: UPDATE
               Table: film
           Statement: begin
    insert into tridemo(note) values('after update');
end
              Timing: AFTER
             Created: 2017-02-01 14:44:03.18
            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
             Definer: root@localhost
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: utf8_bin
5 rows in set (0.00 sec)



另外一个查看方式是查询系统表的 information_schema.triggers 表，这个方式可以查询指定
触发器的指定信息，操作起来明显方便很多：
root@localhost[information_schema] >use information_schema 
Database changed
root@localhost[information_schema] >desc TRIGGERS;
+----------------------------+---------------+------+-----+---------+-------+
| Field                      | Type          | Null | Key | Default | Extra |
+----------------------------+---------------+------+-----+---------+-------+
| TRIGGER_CATALOG            | varchar(512)  | NO   |     |         |       |
| TRIGGER_SCHEMA             | varchar(64)   | NO   |     |         |       |
| TRIGGER_NAME               | varchar(64)   | NO   |     |         |       |
| EVENT_MANIPULATION         | varchar(6)    | NO   |     |         |       |
| EVENT_OBJECT_CATALOG       | varchar(512)  | NO   |     |         |       |
| EVENT_OBJECT_SCHEMA        | varchar(64)   | NO   |     |         |       |
| EVENT_OBJECT_TABLE         | varchar(64)   | NO   |     |         |       |
| ACTION_ORDER               | bigint(4)     | NO   |     | 0       |       |
| ACTION_CONDITION           | longtext      | YES  |     | NULL    |       |
| ACTION_STATEMENT           | longtext      | NO   |     | NULL    |       |
| ACTION_ORIENTATION         | varchar(9)    | NO   |     |         |       |
| ACTION_TIMING              | varchar(6)    | NO   |     |         |       |
| ACTION_REFERENCE_OLD_TABLE | varchar(64)   | YES  |     | NULL    |       |
| ACTION_REFERENCE_NEW_TABLE | varchar(64)   | YES  |     | NULL    |       |
| ACTION_REFERENCE_OLD_ROW   | varchar(3)    | NO   |     |         |       |
| ACTION_REFERENCE_NEW_ROW   | varchar(3)    | NO   |     |         |       |
| CREATED                    | datetime(2)   | YES  |     | NULL    |       |
| SQL_MODE                   | varchar(8192) | NO   |     |         |       |
| DEFINER                    | varchar(93)   | NO   |     |         |       |
| CHARACTER_SET_CLIENT       | varchar(32)   | NO   |     |         |       |
| COLLATION_CONNECTION       | varchar(32)   | NO   |     |         |       |
| DATABASE_COLLATION         | varchar(32)   | NO   |     |         |       |
+----------------------------+---------------+------+-----+---------+-------+
22 rows in set (0.00 sec)


root@localhost[information_schema] >select * from triggers where trigger_name='ins_film_bef' \G
*************************** 1. row ***************************
           TRIGGER_CATALOG: def
            TRIGGER_SCHEMA: test
              TRIGGER_NAME: ins_film_bef
        EVENT_MANIPULATION: INSERT
      EVENT_OBJECT_CATALOG: def
       EVENT_OBJECT_SCHEMA: test
        EVENT_OBJECT_TABLE: film
              ACTION_ORDER: 1
          ACTION_CONDITION: NULL
          ACTION_STATEMENT: begin
    insert into tridemo(note) values('before insert');
end
        ACTION_ORIENTATION: ROW
             ACTION_TIMING: BEFORE
ACTION_REFERENCE_OLD_TABLE: NULL
ACTION_REFERENCE_NEW_TABLE: NULL
  ACTION_REFERENCE_OLD_ROW: OLD
  ACTION_REFERENCE_NEW_ROW: NEW
                   CREATED: 2017-02-01 14:39:42.98
                  SQL_MODE: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
                   DEFINER: root@localhost
      CHARACTER_SET_CLIENT: utf8
      COLLATION_CONNECTION: utf8_general_ci
        DATABASE_COLLATION: utf8_bin
1 row in set (0.01 sec)



13.2 删除触发器
一次可以删除一个触发程序，如果没有指定 schema_name，默认为当前数据库,具体语法如下：
DROP TRIGGER [schema_name.]trigger_name

例如，要删除 film 表上的触发器 ins_film，可以使用以下命令：
root@localhost[information_schema] >drop trigger ins_film;
ERROR 1360 (HY000): Trigger does not exist
root@localhost[information_schema] >drop trigger ins_film2;
ERROR 1360 (HY000): Trigger does not exist
root@localhost[information_schema] >ins_film_bef                                           
root@localhost[information_schema] >drop trigger ins_film_bef;
ERROR 1360 (HY000): Trigger does not exist
root@localhost[information_schema] >use test;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
root@localhost[test] >drop trigger ins_film_bef;
Query OK, 0 rows affected (0.01 sec)


也可以删除information_schema.trigger表中的记录




13.4 触发器的使用
触发器执行的语句有以下两个限制:
1.触发程序不能调用将数据返回客户端的存储程序，也不能使用采用 CALL 语句的动态 SQL语句，但是允许存储程序通过参数将数据返回触发程序
  也就是存储过程 or 函数通过 OUT or INOUT 类型的参数将数据返回给触发器是可以的，但是不能调用直接返回数据的过程

2.不能在触发器中使用以显式 or 隐式方式开始或结束事务的语句，如 START TRANSACTION、COMMIT 或 ROLLBACK

MySQL的触发器是按照 BEFORE 触发器、行操作、AFTER 触发器的顺序执行的，其中任何一步操作发生错误都不会继续执行剩下的操作
如果是对事务表进行的操作，那么会整个作为一个事务被回滚（Rollback）
但是如果是对非事务表进行的操作，那么已经更新的记录将无法回滚，这也是设计触发器的时候需要注意的问题



13.5 小结
本节主要介绍了触发器的定义、修改以及触发器使用的一些注意事项
需要注意的是触发器是行触发的，每次增加、修改或者删除记录都会触发进行行处理，编写过于复杂的触发器或者
    增加过多的触发器对记录的插入、更新、删除操作肯定会有比较严重的影响
因此数据库设计的时候要有所考虑，不要将应用的处理逻辑过多的依赖于触发器来处理
