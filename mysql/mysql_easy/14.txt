                                         第14章 事务控制和锁定语句

1.MySQL 支持对 MyISAM 和 MEMORY 存储引擎的表进行表级锁定，对 BDB 存储引擎的表进行页级锁定，对 InnoDB 存储引擎的表进行行级锁定
2.默认情况下，表锁和行锁都是自动获得的，不需要额外的命令
3.但是在有的情况下，用户需要明确地进行锁表或者进行事务的控制，以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成
    有关锁机制、不同存储引擎对锁的处理、死锁等内容，将会在后面的优化篇中进行更详细的介绍，有兴趣的读者可以参见相关的章节


14.1 LOCK TABLE 和 UNLOCK TABLE
1.LOCK TABLES  可以锁定用于当前线程的表
      如果表被其它线程锁定，则当前线程会等待，直到可以获取所有锁定为止

2.UNLOCK TABLES 可以释放当前线程获得的任何锁定
      当前线程执行另一个 LOCK TABLES 时，或当与服务器的连接被关闭时，所有由当前线程锁定的表被隐含地解锁，具体语法如下：


http://dev.mysql.com/doc/refman/5.7/en/lock-tables.html
sys@localhost[test] >help lock
Name: 'LOCK'
Description:
Syntax:
LOCK TABLES
    tbl_name [[AS] alias] lock_type
    [, tbl_name [[AS] alias] lock_type] ...

lock_type:
    READ [LOCAL]
  | [LOW_PRIORITY] WRITE

UNLOCK TABLES


官方5.7实验测试:
一、
root@localhost[test] >lock tables actor read;        
Query OK, 0 rows affected (0.00 sec)

root@localhost[test] >select * from actor limit 2;
+----------+------------+-----------+
| actor_id | first_name | last_name |
+----------+------------+-----------+
|        1 | xxx        | 201       |
|        2 | xxx        | 201       |
+----------+------------+-----------+
2 rows in set (0.01 sec)

root@localhost[test] >insert into actor values(210,'yyy','210');
ERROR 1099 (HY000): Table 'actor' was locked with a READ lock and can't be updated
root@localhost[test] >
root@localhost[test] >unlock tables actor;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'actor' at line 1
root@localhost[test] >unlock tables;      
Query OK, 0 rows affected (0.00 sec)

root@localhost[test] >insert into actor values(210,'yyy','210');
Query OK, 1 row affected (0.01 sec)




二、
root@localhost[test] >lock tables actor read;
Query OK, 0 rows affected (0.00 sec)

root@localhost[test] >select * from actor limit 2;
+----------+------------+-----------+
| actor_id | first_name | last_name |
+----------+------------+-----------+
|        1 | xxx        | 201       |
|        2 | xxx        | 201       |
+----------+------------+-----------+
2 rows in set (0.00 sec)

root@localhost[test] >select count(*) from actor;         
+----------+
| count(*) |
+----------+
|      105 |
+----------+
1 row in set (0.00 sec)

root@localhost[test] >select count(*) from user2;
ERROR 1100 (HY000): Table 'user2' was not locked with LOCK TABLES




三、
root@localhost[test] >lock tables actor write, actor as a2 read;
Query OK, 0 rows affected (0.00 sec)

root@localhost[test] >select count(*) from actor;
+----------+
| count(*) |
+----------+
|      105 |
+----------+
1 row in set (0.00 sec)

root@localhost[test] >select count(*) from a2;   
ERROR 1100 (HY000): Table 'a2' was not locked with LOCK TABLES
root@localhost[test] >
root@localhost[test] >insert into actor select * from actor;
ERROR 1100 (HY000): Table 'actor' was not locked with LOCK TABLES
root@localhost[test] >
root@localhost[test] >insert into actor select * from actor as a2;
ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY'

The error occurs for the first INSERT because there are two references to the same name for a locked table. The second INSERT succeeds because the references to the table use different names



四、
If your statements refer to a table by means of an alias, you must lock the table using that same alias. It does not work to lock the table without specifying the alias:

root@localhost[test] >unlock tables;
Query OK, 0 rows affected (0.00 sec)

root@localhost[test] >lock tables actor read;
Query OK, 0 rows affected (0.00 sec)

root@localhost[test] >select * from actor as myalias;
ERROR 1100 (HY000): Table 'myalias' was not locked with LOCK TABLES



五、
Conversely, if you lock a table using an alias, you must refer to it in your statements using that alias:

root@localhost[test] >unlock tables ;
Query OK, 0 rows affected (0.00 sec)

root@localhost[test] >lock tables actor as myalias read;
Query OK, 0 rows affected (0.00 sec)

root@localhost[test] >select * from actor;
ERROR 1100 (HY000): Table 'actor' was not locked with LOCK TABLES
root@localhost[test] >
root@localhost[test] >select * from actor as myalias;
+----------+------------+-----------+
| actor_id | first_name | last_name |
+----------+------------+-----------+
|        1 | xxx        | 201       |
.....................................




如表 14-1 所示是一个获得表锁和释放表锁的简单例子:
演示的是 film_text 表获得 read 锁的情况，其它 session 更新该表记录会等待锁，film_text 表释放锁以后，其它session可以进行更新操作
其中 session1 和 session2 表示两个同时打开的 session
表格中的每一行表示同一时刻两个 session 的运行状况，后面的例子也都是同样格式，不再重复说明

表 14-1 一个获得表锁和释放表锁的简单例子


session1 锁定表user后,session1 and session2同时做的操作:
root@localhost[test] >select * from user;
+----+-------+
| id | name  |
+----+-------+
| 1  | fuck  |
| 6  | nimei |
| 8  | nimei |
+----+-------+
3 rows in set (0.00 sec)

root@localhost[test] >lock tables user read;
Query OK, 0 rows affected (0.00 sec)


session1:
root@localhost[test] >select * from user;
+----+-------+
| id | name  |
+----+-------+
| 1  | fuck  |
| 6  | nimei |
| 8  | nimei |
+----+-------+
3 rows in set (0.00 sec)

root@localhost[test] >select * from user2;
ERROR 1100 (HY000): Table 'user2' was not locked with LOCK TABLES


session2:
root@localhost[test] >select * from user;
+----+-------+
| id | name  |
+----+-------+
| 1  | fuck  |
| 6  | nimei |
| 8  | nimei |
+----+-------+
3 rows in set (0.00 sec)

root@localhost[test] >select * from user2;
+----+------+
| id | name |
+----+------+
| 1  | test |
+----+------+
1 row in set (0.00 sec)



此时session2做update操作,会等待其它session释放锁,这里是session1：
session2:
root@localhost[test] >update user set name='xxx' where id=1;



敲完回车一直卡着


session1:
root@localhost[test] >unlock tables;
Query OK, 0 rows affected (0.00 sec)


session2:
root@localhost[test] >update user set name='xxx' where id=1;




Query OK, 1 row affected (1 min 0.99 sec)






14.2 事务控制
MySQL 通过 SET AUTOCOMMIT、START TRANSACTION、COMMIT 和 ROLLBACK 等语句支持本地事务，具体语法如下:

sys@localhost[test] >help start transaction
Name: 'START TRANSACTION'
Description:
Syntax:
START TRANSACTION
    [transaction_characteristic [, transaction_characteristic] ...]

transaction_characteristic:
    WITH CONSISTENT SNAPSHOT
  | READ WRITE
  | READ ONLY

BEGIN [WORK]
COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
SET autocommit = {0 | 1}

These statements provide control over use of transactions:

o START TRANSACTION or BEGIN start a new transaction.

o COMMIT commits the current transaction, making its changes permanent.

o ROLLBACK rolls back the current transaction, canceling its changes.

o SET autocommit disables or enables the default autocommit mode for the current session.



1.默认情况下，MySQL 是自动提交（Autocommit）的，如果需要通过明确的 Commit 和 Rollback 来提交和回滚事务，
  那么需要通过明确的事务控制命令来开始事务，这是和 Oracle的事务管理明显不同的地方

2.如果应用是从 Oracle 数据库迁移到 MySQL 数据库，则需要确保应用中是否对事务进行了明确的管理

3.START TRANSACTION 或 BEGIN 语句可以开始一项新的事务

4.COMMIT 和 ROLLBACK 用来提交或者回滚事务

5.CHAIN 和 RELEASE 子句分别用来定义在事务提交或者回滚之后的操作:
   a.CHAIN 会立即启动一个新事务，并且和刚才的事务具有相同的隔离级别
   b.RELEASE 则会断开和客户端的连接

6.SET AUTOCOMMIT 可以修改当前连接的提交方式:
  如果设置了 SET AUTOCOMMIT=0，则设置之后的所有事务都需要通过明确的命令进行提交或者回滚

7.如果只是对某些语句需要进行事务控制,则使用 START TRANSACTION 语句开始一个事务比较方便,这样事务结束之后可以自动回到自动提交的方式

8.如果希望所有的事务都不是自动提交的,通过修改AUTOCOMMIT来控制事务比较方便,这样不用在每个事务开始的时候再执行 START TRANSACTION 语句

如表 14-2 所示的例子演示了使用 START TRANSACTION 开始的事务在提交后自动回到自动提交的方式；
如果在提交的时候使用 COMMIT AND CHAIN，那么会在提交后立即开始一个新的事务



