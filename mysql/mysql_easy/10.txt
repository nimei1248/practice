                                 第10章  索引的设计和使用
2017-1-19 22:53
索引是数据库中用来提高性能的最常用工具

本章主要介绍了MySQL 5.0支持的索引类型, 并简单介绍了索引的设计原则。
在后面的优化篇中,将会对索引做更多的介绍


10.1 索引概述
1.所有 MySQL 列类型都可以被索引,对相关列使用索引是提高 SELECT 操作性能的最佳途径
2.根据存储引擎可以定义每个表的最大索引数和最大索引长度,每种存储引擎(如 MyISAM、 InnoDB、BDB、MEMORY等)
    对每个表至少支持 16 个索引,总索引长度至少为 256 字节。 大多数存储引擎有更高的限制。
3.MyISAM 和 InnoDB 存储引擎的表默认创建的都是 BTREE 索引
4.MySQL 目前还不支持函数索引,但是支持前缀索引,即对索引字段的前 N 个字符创建索引
    前缀索引的长度跟存储引擎相关,对于 MyISAM 存储引擎的表,索引的前缀长度可以达到 1000 字节,
    而对于 InnoDB 存储引擎的表,索引的前缀长度最长是 767 字节
    请注意前缀的限制应以字节为单位进行测量,而CREATE TABLE语句中的前缀长度解释为字符数,
    在为使用多字节字符集的 列 指定前缀长度时一定要加以考虑。
5.MySQL 中还支持全文本(FULLTEXT)索引,该索引可用于全文搜索
    a.但是当前最新版 本中(5.0)只有 MyISAM 存储引擎支持 FULLTEXT 索引,并且只限于 CHAR、VARCHAR 和 TEXT 列
    b.索引总是对整个列进行的,不支持局部(前缀)索引
6.也可以为空间列类型创建索引,但是只有 MyISAM 存储引擎支持空间类型索引,且索引的字段必须是非空的
7.默认情况下,MEMORY 存储引擎使用 HASH 索引,但也支持 BTREE 索引
8.索引在创建表的时候可以同时创建,也可以随时增加新的索引

创建新索引的语法为:
5.7:
mysql> help create index
Name: 'CREATE INDEX'
Description:
Syntax:
CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name
    [index_type]
    ON tbl_name (index_col_name,...)
    [index_option]
    [algorithm_option | lock_option] ...

index_col_name:
    col_name [(length)] [ASC | DESC]

index_type:
    USING {BTREE | HASH}

index_option:
    KEY_BLOCK_SIZE [=] value
  | index_type
  | WITH PARSER parser_name
  | COMMENT 'string'

algorithm_option:
    ALGORITHM [=] {DEFAULT|INPLACE|COPY}

lock_option:
    LOCK [=] {DEFAULT|NONE|SHARED|EXCLUSIVE}

CREATE INDEX is mapped to an ALTER TABLE statement to create indexes.
See [HELP ALTER TABLE]. CREATE INDEX cannot be used to create a PRIMARY
KEY; use ALTER TABLE instead. For more information about indexes, see
http://dev.mysql.com/doc/refman/5.7/en/mysql-indexes.html.

URL: http://dev.mysql.com/doc/refman/5.7/en/create-index.html



sys@localhost[(none)] >help alter table
Name: 'ALTER TABLE'
Description:
Syntax:
ALTER [ONLINE|OFFLINE] [IGNORE] TABLE tbl_name
    [alter_specification [, alter_specification] ...]
    [partition_options]

  | ADD {INDEX|KEY} [index_name]
        [index_type] (index_col_name,...) [index_option] ...

index_col_name:
    col_name [(length)] [ASC | DESC]

index_type:
    USING {BTREE | HASH}

index_option:
    KEY_BLOCK_SIZE [=] value
  | index_type
  | WITH PARSER parser_name
  | COMMENT 'string'

  | DROP {INDEX|KEY} index_name


mysql>use test;
mysql>drop table country;
mysql> create table country (country_id smallint unsigned not null auto_increment, country varchar(50) not null, last_update timestamp not null default current_timestamp on update current_timestamp, primary key (country_id) ) engine=innodb default charset=utf8;
Query OK, 0 rows affected (0.02 sec)

mysql>drop table city;
mysql> create table city (city_id smallint unsigned not null auto_increment, city varchar(50) not null, country_id smallint unsigned not null, last_update timestamp not null default current_timestamp on update current_timestamp, primary key (city_id), key idx_fk_country_id (country_id), constraint `fk_city_country` foreign key (country_id) references country (country_id) on delete restrict on update cascade ) engine=innodb default charset=utf8;
Query OK, 0 rows affected (0.02 sec)



mysql> desc country;
+-------------+----------------------+------+-----+-------------------+-----------------------------+
| Field       | Type                 | Null | Key | Default           | Extra                       |
+-------------+----------------------+------+-----+-------------------+-----------------------------+
| country_id  | smallint(5) unsigned | NO   | PRI | NULL              | auto_increment              |
| country     | varchar(50)          | NO   |     | NULL              |                             |
| last_update | timestamp            | NO   |     | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |
+-------------+----------------------+------+-----+-------------------+-----------------------------+
3 rows in set (0.00 sec)

mysql> desc city;
+-------------+----------------------+------+-----+-------------------+-----------------------------+
| Field       | Type                 | Null | Key | Default           | Extra                       |
+-------------+----------------------+------+-----+-------------------+-----------------------------+
| city_id     | smallint(5) unsigned | NO   | PRI | NULL              | auto_increment              |
| city        | varchar(50)          | NO   |     | NULL              |                             |
| country_id  | smallint(5) unsigned | NO   | MUL | NULL              |                             |
| last_update | timestamp            | NO   |     | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |
+-------------+----------------------+------+-----+-------------------+-----------------------------+
4 rows in set (0.01 sec)


mysql> insert into country (country,last_update) values ('Afghanistan','2017-01-17 14:45:00');
Query OK, 1 row affected (0.00 sec)
mysql> insert into country (country,last_update) values ('China','2017-01-20 14:45:00');
Query OK, 1 row affected (0.01 sec)


mysql> select * from country;
+------------+-------------+---------------------+
| country_id | country     | last_update         |
+------------+-------------+---------------------+
|          1 | Afghanistan | 2017-01-17 14:45:00 |
|          3 | China       | 2017-01-20 14:45:00 |
+------------+-------------+---------------------+
2 rows in set (0.00 sec)


mysql> insert into city (city,country_id,last_update) values ('Kabul',1,'2017-01-17 14:46:00');
Query OK, 1 row affected (0.00 sec)
mysql> insert into city (city,country_id,last_update) values ('BJ',3,'2017-01-20 14:46:00');
Query OK, 1 row affected (0.01 sec)



mysql> select * from city;
+---------+-------+------------+---------------------+
| city_id | city  | country_id | last_update         |
+---------+-------+------------+---------------------+
|       1 | Kabul |          1 | 2017-01-17 14:46:00 |
|       3 | BJ    |          3 | 2017-01-20 14:46:00 |
+---------+-------+------------+---------------------+
2 rows in set (0.00 sec)




解析查询sql看看是否走索引
mysql> explain select * from city where city='BJ'\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: city
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 2
     filtered: 50.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)



创建索引
mysql> create index cityname on city (city(10));
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0


查看索引
mysql> show create table city\G
*************************** 1. row ***************************
       Table: city
Create Table: CREATE TABLE `city` (
  `city_id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
  `city` varchar(50) NOT NULL,
  `country_id` smallint(5) unsigned NOT NULL,
  `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`city_id`),
  ## 索引名称
  KEY `idx_fk_country_id` (`country_id`),
  ## 索引名称
  KEY `cityname` (`city`(10)),
  CONSTRAINT `fk_city_country` FOREIGN KEY (`country_id`) REFERENCES `country` (`country_id`) ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8
1 row in set (0.00 sec)

mysql> explain select * from city where city='BJ'\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: city
   partitions: NULL
         type: ref
possible_keys: cityname
          key: cityname
      key_len: 32
          ref: const
         rows: 1
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)



mysql> explain select * from city where country_id=3\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: city
   partitions: NULL
         type: ref
possible_keys: idx_fk_country_id
          key: idx_fk_country_id
      key_len: 2
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)



索引的删除语法为:
DROP INDEX index_name ON tbl_name
例如,想要删除 city 表上的索引 cityname,可以操作如下:


mysql> drop index cityname on city;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> show create table city\G
*************************** 1. row ***************************
       Table: city
Create Table: CREATE TABLE `city` (
  `city_id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
  `city` varchar(50) NOT NULL,
  `country_id` smallint(5) unsigned NOT NULL,
  `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`city_id`),
  KEY `idx_fk_country_id` (`country_id`),
  CONSTRAINT `fk_city_country` FOREIGN KEY (`country_id`) REFERENCES `country` (`country_id`) ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8
1 row in set (0.00 sec)

mysql> explain select * from city where city='BJ'\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: city
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 2
     filtered: 50.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)




10.2 设计索引的原则

索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效地使用索引

1.搜索的索引列
  a.不一定是所要选择的列
    换句话说，最适合索引的列是出现在 WHERE 子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列

2.使用惟一索引
  a.考虑某列中值的分布。索引的列的基数越大，索引的效果越好
    例如，存放出生日期的列具有不同值，很容易区分各行
          而用来记录性别的列,只含有"M"和"F"，则对此列进行索引没有多大用处，因为不管搜索哪个值，都会得出大约一半的行

3.使用短索引
  a.如果对字符串列进行索引,应该指定一个前缀长度,只要有可能就应该这样做
    例如，a.如果有一个 CHAR(200)列，如果在前 10 个或 20 个字符内，多数值是惟一的,那么就不要对整个列进行索引
            对前 10 个或 20 个字符进行索引能够节省大量索引空间，也可能会使查询更快较小的索引涉及的磁盘 IO 较少，
            较短的值比较起来更快
          b.更为重要的是，对于较短的键值，索引高速缓存中的块能容纳更多的键值，因此，MySQL也可以在内存中容纳更多的值
            这样就增加了找到行而不用读取索引中较多块的可能性

4.利用最左前缀
  a.在创建一个 n 列的索引时，实际是创建了 MySQL 可利用的 n 个索引
  b.多列索引可起几个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集称为最左前缀

5.不要过度索引
  a.不要以为索引“越多越好” ，什么东西都用索引是错误的
  b.每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能
  c.在修改表的内容时，索引必须进行更新，有时可能需要重构，因此，索引越多，所花的时间越长
  d.如果有一个索引很少利用或从不使用，那么会不必要地减缓表的修改速度
  e.MySQL 在生成一个执行计划时，要考虑各个索引，这也要花费时间
  f.创建多余的索引给查询优化带来了更多的工作。索引太多，也可能会使 MySQL 选择不到所要使用的最好索引
  g.只保持所需的索引有利于查询优化。
 h.对于 InnoDB 存储引擎的表，记录默认会按照一定的顺序保存
    1.如果有明确定义的主键，则按照主键顺序保存
    2.如果没有主键，但是有唯一索引，那么就是按照唯一索引的顺序保存
    3.如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个列的顺序保存
    4.按照主键或者内部列进行的访问是最快的，所以 InnoDB 表尽量自己指定主键，当表中同时有几个列都是唯一的，
      都可以作为主键的时候，要选择最常作为访问条件的列作为主键，提高查询的效率
    5.还需要注意，InnoDB 表的普通索引都会保存主键的键值，所以主键要尽可能选择较短的数据类型，
      可以有效地减少索引的磁盘占用，提高索引的缓存效果





10.3 BTREE 索引与 HASH 索引

MEMORY 存储引擎的表可以选择使用 BTREE 索引或者 HASH 索引，两种不同类型的索引各有其不同的适用范围
HASH 索引有一些重要的特征需要在使用的时候特别注意，如下所示:
 1.只用于使用=或<=>操作符的等式比较
 2.优化器不能使用 HASH 索引来加速 ORDER BY 操作
 3.MySQL不能确定在两个值之间大约有多少行
    如果将一个 MyISAM 表改为 HASH 索引的 MEMORY 表，会影响一些查询的执行效率
 4.只能使用整个关键字来搜索一行

对于 BTREE 索引，当使用>、<、>=、<=、BETWEEN、!=或者<>，或者 LIKE 'pattern'（其中'pattern'不以通配符开始）操作符时，
     都可以使用相关列上的索引


下列范围查询适用于 BTREE 索引和 HASH 索引：
SELECT * FROM t1 WHERE key_col = 1 OR key_col IN (15,18,20);

下列范围查询只适用于 BTREE 索引：
SELECT * FROM t1 WHERE key_col > 1 AND key_col < 10;
SELECT * FROM t1 WHERE key_col LIKE 'ab%' OR key_col BETWEEN 'lisa' AND 'simon';


例如，创建一个和 city 表完全相同的 MEMORY 存储引擎的表 city_memory：
root@localhost[test] >create table city_memory( city_id smallint unsigned not null auto_increment, city varchar(50) not null, country_id smallint unsigned not null, last_update timestamp not null default current_timestamp on update current_timestamp, primary key(city_id), key idx_fk_country_id (country_id) ) engine=memory default charset=utf8;


root@localhost[test] >desc city_memory;
+-------------+----------------------+------+-----+-------------------+-----------------------------+
| Field       | Type                 | Null | Key | Default           | Extra                       |
+-------------+----------------------+------+-----+-------------------+-----------------------------+
| city_id     | smallint(5) unsigned | NO   | PRI | NULL              | auto_increment              |
| city        | varchar(50)          | NO   |     | NULL              |                             |
| country_id  | smallint(5) unsigned | NO   | MUL | NULL              |                             |
| last_update | timestamp            | NO   |     | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |
+-------------+----------------------+------+-----+-------------------+-----------------------------+
4 rows in set (0.01 sec)

root@localhost[test] >select * from city;
+---------+-------+------------+---------------------+
| city_id | city  | country_id | last_update         |
+---------+-------+------------+---------------------+
|       1 | Kabul |       1000 | 2017-01-17 14:46:00 |
+---------+-------+------------+---------------------+
1 row in set (0.02 sec)

root@localhost[test] >insert into city_memory select * from city;
Query OK, 1 row affected (0.01 sec)
Records: 1  Duplicates: 0  Warnings: 0

root@localhost[test] >select * from city_memory;                 
+---------+-------+------------+---------------------+
| city_id | city  | country_id | last_update         |
+---------+-------+------------+---------------------+
|       1 | Kabul |       1000 | 2017-01-17 14:46:00 |
+---------+-------+------------+---------------------+
1 row in set (0.00 sec)



当对索引字段进行范围查询的时候，只有 BTREE 索引可以通过索引访问：
root@localhost[test] >explain select * from city where country_id > 1 and country_id < 10 \G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: city
   partitions: NULL
         type: range
possible_keys: idx_fk_country_id
          key: idx_fk_country_id
      key_len: 2
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: Using index condition
1 row in set, 1 warning (0.01 sec)



而 HASH 索引实际上是全表扫描的：
root@localhost[test] >explain select * from city_memory where country_id > 1 and country_id < 10 \G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: NULL
   partitions: NULL
         type: NULL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
     filtered: NULL
        Extra: Impossible WHERE noticed after reading const tables
1 row in set, 1 warning (0.00 sec)

root@localhost[test] >show warnings;
+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Level | Code | Message                                                                                                                                                                 |
+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Note  | 1003 | /* select#1 */ select '1' AS `city_id`,'Kabul' AS `city`,'1000' AS `country_id`,'2017-01-17 14:46:00' AS `last_update` from dual where (('1000' > 1) and ('1000' < 10)) |
+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.01 sec)


了解了 BTREE 索引和 HASH 索引不同后， 当使用 MEMORY 表的时候:
1.如果是默认创建的 HASH 索引，就要注意 SQL 语句的编写，确保可以使用上索引
2.如果一定要使用范围查询，那么在创建索引的时候，就应该选择创建成 BTREE 索引




10.4 小结

索引用于快速找出在某个列中有一特定值的行
1.如果不使用索引，MySQL 必须从第 1 条记录开始然后读完整个表直到找出相关的行;表越大，花费的时间越多
2.如果表中查询的列有一个索引，MySQL 能快速到达一个位置去搜寻数据文件的中间，没有必要看所有数据
    如果一个表有 1000 行，这比顺序读取至少快 100 倍
3.注意如果需要访问大部分行，顺序读取要快得多，因为此时应避免磁盘搜索
4.大多数 MySQL 索引（如 PRIMARY KEY、UNIQUE、INDEX 和 FULLTEXT 等）在 BTREE 中存储
    只是空间列类型的索引使用 RTREE，并且 MEMORY 表还支持 HASH 索引
5.关于什么情况下数据库会使用索引，以及什么情况下数据库不会使用索引的详细介绍,可参见优化篇的相关章节，这里不再赘述




alter:
root@localhost[test] >show create table city\G
*************************** 1. row ***************************
       Table: city
Create Table: CREATE TABLE `city` (
  `city_id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
  `city` varchar(50) NOT NULL,
  `country_id` smallint(5) unsigned NOT NULL,
  `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`city_id`),
  KEY `idx_fk_country_id` (`country_id`),
  CONSTRAINT `fk_city_country` FOREIGN KEY (`country_id`) REFERENCES `country` (`country_id`) ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8
1 row in set (0.00 sec)

root@localhost[test] >
root@localhost[test] >alter table city comment = '城市表';  
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0

root@localhost[test] >show create table city\G            
*************************** 1. row ***************************
       Table: city
Create Table: CREATE TABLE `city` (
  `city_id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
  `city` varchar(50) NOT NULL,
  `country_id` smallint(5) unsigned NOT NULL,
  `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`city_id`),
  KEY `idx_fk_country_id` (`country_id`),
  CONSTRAINT `fk_city_country` FOREIGN KEY (`country_id`) REFERENCES `country` (`country_id`) ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COMMENT='城市表'
1 row in set (0.00 sec)

root@localhost[test] >use information_schema 
root@localhost[information_schema] >select * from tables where TABLE_NAME='city'\G
*************************** 1. row ***************************
  TABLE_CATALOG: def
   TABLE_SCHEMA: test
     TABLE_NAME: city
     TABLE_TYPE: BASE TABLE
         ENGINE: InnoDB
        VERSION: 10
     ROW_FORMAT: Dynamic
     TABLE_ROWS: 1
 AVG_ROW_LENGTH: 16384
    DATA_LENGTH: 16384
MAX_DATA_LENGTH: 0
   INDEX_LENGTH: 16384
      DATA_FREE: 0
 AUTO_INCREMENT: 2
    CREATE_TIME: 2017-01-20 13:38:21
    UPDATE_TIME: 2017-01-17 14:47:54
     CHECK_TIME: NULL
TABLE_COLLATION: utf8_general_ci
       CHECKSUM: NULL
 CREATE_OPTIONS: 
  TABLE_COMMENT: 城市表
1 row in set (0.00 sec)
