                                                            第2篇 开发篇
                                                    第7章 表类型(存储引擎)的选择


和大多数数据库不同,MySQL 中有一个存储引擎的概念,针对不同的存储需求可以选择最优的存储引擎
本章将详细介绍存储引擎的概念、分类以及实际应用中的选择原则


7.1 MySQL存储引擎概述
插件式存储引擎是 MySQL 数据库最重要的特性之一,用户可以根据应用的需要选择如何存储和索引数据、是否使用事务等
MySQL 默认支持多种存储引擎,以适用于不同领域的数据库应用需要,用户可以通过选择使用不同的存储引擎提高应用的效率,提供灵活的存储,
用户甚至可以按照自己的需要定制和使用自己的存储引擎,以实现最大程度的可定制性

MySQL 5.0 支持的存储引擎包括 MyISAM、InnoDB、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等,
其中InnoDB和BDB提供事务安全表,其它存储引擎都是非事务安全表

默认情况下,创建新表不指定表的存储引擎,则新表是默认存储引擎,如果需要修改默认的存储引擎,则可以在参数文件中设置default-table-type

1.查看当前的默认存储引擎, 可以使用以下命令:
mysql> show variables like '%engine%';
+----------------------------------+--------+
| Variable_name                    | Value  |
+----------------------------------+--------+
| default_storage_engine           | InnoDB |
| default_tmp_storage_engine       | InnoDB |
| disabled_storage_engines         |        |
| internal_tmp_disk_storage_engine | InnoDB |
+----------------------------------+--------+
4 rows in set (0.00 sec)


2.可以通过下面两种方法查询当前数据库支持的存储引擎,第一种方法为:
mysql> show engines;
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
9 rows in set (0.00 sec)


3.查看mysql表的存储引擎
3.1 show table status from dbname where name='tablename'\G

mysql> show table status from test where name='salary'\G
*************************** 1. row ***************************
           Name: salary
         Engine: InnoDB
        Version: 10
     Row_format: Dynamic
           Rows: 10
 Avg_row_length: 1638
    Data_length: 16384
Max_data_length: 0
   Index_length: 0
      Data_free: 0
 Auto_increment: NULL
    Create_time: 2017-01-12 22:55:51
    Update_time: NULL
     Check_time: NULL
      Collation: utf8_general_ci
       Checksum: NULL
 Create_options:
        Comment:
1 row in set (0.00 sec)


3.2 mysqlshow -uroot --status dbname tablename

mysqlshow -uroot --status mysql user
mysqlshow -uroot -p -h localhost -S /mysqldata/inst1/sock/mysql.sock --status mysql user

Database: mysql  Wildcard: user
+------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------+----------+----------------+-----------------------------+
| Name | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time         | Update_time         | Check_time | Collation | Checksum | Create_options | Comment                     |
+------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------+----------+----------------+-----------------------------+
| user | MyISAM | 10      | Dynamic    | 2    | 104            | 208         | 281474976710655 | 4096         | 0         |                | 2017-01-08 15:10:22 | 2017-01-08 15:10:25 |            | utf8_bin  |          |                | Users and global privileges |
+------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------+----------+----------------+-----------------------------+


3.3 mysql> show create table test.salary;
+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table  | Create Table                                                                                                                                                        |
+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| salary | CREATE TABLE `salary` (
  `userid` int(11) DEFAULT NULL,
  `salary` decimal(9,2) DEFAULT NULL,
  `ip` varchar(20) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 |
+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)


3.3 mysql> show variables like '%engine%';
+----------------------------------+--------+
| Variable_name                    | Value  |
+----------------------------------+--------+
| default_storage_engine           | InnoDB |
| default_tmp_storage_engine       | InnoDB |
| disabled_storage_engines         |        |
| internal_tmp_disk_storage_engine | InnoDB |
+----------------------------------+--------+
4 rows in set (0.00 sec)


以上方法都可以用来查看当前支持哪些存储引擎,其中 Value 显示为“DISABLED” 的记录表示支持该存储引擎,但是数据库启动的时候被禁用。

4.在创建新表的时候,可以通过增加 ENGINE 关键字设置新建表的存储引擎
例如,在下面的例子中,表 ai 就是 MyISAM 存储引擎的,而 country 表就是 InnoDB 存储引擎的:

mysql> use test;
Database changed
mysql> create table ai (
    -> i bigint(20) not null auto_increment,
    -> primary key (i)
    -> ) engine=MyISAM default charset=gbk;
Query OK, 0 rows affected (0.02 sec)

mysql> desc ai;
+-------+------------+------+-----+---------+----------------+
| Field | Type       | Null | Key | Default | Extra          |
+-------+------------+------+-----+---------+----------------+
| i     | bigint(20) | NO   | PRI | NULL    | auto_increment |
+-------+------------+------+-----+---------+----------------+
1 row in set (0.00 sec)

mysql> show table status from test where name='ai'\G
*************************** 1. row ***************************
           Name: ai
         Engine: MyISAM
        Version: 10
     Row_format: Fixed
           Rows: 0
 Avg_row_length: 0
    Data_length: 0
Max_data_length: 2533274790395903
   Index_length: 1024
      Data_free: 0
 Auto_increment: 1
    Create_time: 2017-01-13 22:53:17
    Update_time: 2017-01-13 22:53:17
     Check_time: NULL
      Collation: gbk_chinese_ci
       Checksum: NULL
 Create_options:
        Comment:
1 row in set (0.00 sec)



mysql> create table country (
    -> country_id smallint unsigned not null auto_increment,
    -> country varchar(50) not null,
    -> last_update timestamp not null default current_timestamp on update current_timestamp,
    -> primary key (country_id)
    -> ) engine=InnoDB default charset=gbk;
Query OK, 0 rows affected (0.02 sec)

mysql> desc country;
+-------------+----------------------+------+-----+-------------------+-----------------------------+
| Field       | Type                 | Null | Key | Default           | Extra                       |
+-------------+----------------------+------+-----+-------------------+-----------------------------+
| country_id  | smallint(5) unsigned | NO   | PRI | NULL              | auto_increment              |
| country     | varchar(50)          | NO   |     | NULL              |                             |
| last_update | timestamp            | NO   |     | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |
+-------------+----------------------+------+-----+-------------------+-----------------------------+
3 rows in set (0.00 sec)

mysql> show table status from test where name='country'\G
*************************** 1. row ***************************
           Name: country
         Engine: InnoDB
        Version: 10
     Row_format: Dynamic
           Rows: 0
 Avg_row_length: 0
    Data_length: 16384
Max_data_length: 0
   Index_length: 0
      Data_free: 0
 Auto_increment: 1
    Create_time: 2017-01-13 22:57:44
    Update_time: NULL
     Check_time: NULL
      Collation: gbk_chinese_ci
       Checksum: NULL
 Create_options:
        Comment:
1 row in set (0.00 sec)


5.使用 ALTER TABLE 语句,将一个已经存在的表修改成其它的存储引擎

下面的例子介绍了如何将表 ai 从 MyISAM 存储引擎修改成 InnoDB 存储引擎:
mysql> alter table ai engine = innodb;
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> show create table ai\G
*************************** 1. row ***************************
       Table: ai
  Create Table: CREATE TABLE `ai` (
  `i` bigint(20) NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`i`)
) ENGINE=InnoDB DEFAULT CHARSET=gbk
1 row in set (0.00 sec)


这样修改后,ai 表成为 InnoDB 存储引擎,可以使用 InnoDB 存储引擎的相关特性




7.2 各种存储引擎的特性
下面重点介绍几种常用的存储引擎,并对比各个存储引擎之间的区别，以帮助读者理解不同存储引擎的使用方式

特点		   MyISAM    InnoDB     MEMORY    MERGE    NDB
存储限制	   有        64TB       有        没有     有
事务安全		     支持
锁机制		   表锁      行锁       表锁      表锁     行锁
B 树索引	   支持      支持       支持      支持     支持
哈希索引				支持               支持
全文索引	   支持
集群索引		     支持
数据缓存		     支持       支持               支持
索引缓存	   支持      支持       支持      支持     支持
数据可压缩	   支持
空间使用	   低        高         N/A       低       低
内存使用	   低        高         中等      低       高
支持外键		     支持
批量插入的速度     高        低         高        高       高


5.7:
http://dev.mysql.com/doc/refman/5.7/en/storage-engines.html

Feature	                                MyISAM	Memory	InnoDB	Archive	NDB      说明
Storage limits	                        256TB	RAM	64TB	None	384EB    存储限制
Transactions	                        No	No	Yes	No	Yes      是否支持事务
Locking granularity	                Table	Table	Row	Row	Row      锁机制/粒度
MVCC	                                No	No	Yes	No	No       多版本并发控制
Geospatial data type support	        Yes	No	Yes	Yes	Yes      地理空间数据类型支持
Geospatial indexing support	        Yes	No	Yes[a]	No	No       地理空间索引支持
B-tree indexes	                        Yes	Yes	Yes	No	No       B树索引
T-tree indexes	                        No	No	No	No	Yes      T树索引
Hash indexes	                        No	Yes	No[b]	No	Yes      hash索引
Full-text search indexes	        Yes	No	Yes[c]	No	No       全文搜索索引
Clustered indexes	                No	No	Yes	No	No       集群索引
Data caches	                        No	N/A	Yes	No	Yes      数据缓存
Index caches	                        Yes	N/A	Yes	No	Yes      索引缓存
Compressed data	                        Yes[d]	No	Yes[e]	Yes	No       压缩数据
Encrypted data[f]	                Yes	Yes	Yes	Yes	Yes      加密数据
Cluster database support	        No	No	No	No	Yes      集群数据支持
Replication support[g]	                Yes	Yes	Yes	Yes	Yes      复制支持
Foreign key support	                No	No	Yes	No	No       外键支持
Backup / point-in-time recovery[h]	Yes	Yes	Yes	Yes	Yes      备份/时间点恢复[h]
Query cache support	                Yes	Yes	Yes	Yes	Yes      查询缓存支持
Update statistics for data dictionary	Yes	Yes	Yes	Yes	Yes      更新数据字典的统计信息


[a] InnoDB support for geospatial indexing is available in MySQL 5.7.5 and higher.
[b] InnoDB utilizes hash indexes internally for its Adaptive Hash Index feature.
[c] InnoDB support for FULLTEXT indexes is available in MySQL 5.6.4 and higher.
[d] Compressed MyISAM tables are supported only when using the compressed row format.
    Tables using the compressed row format with MyISAM are read only.
[e] Compressed InnoDB tables require the InnoDB Barracuda file format.
[f] Implemented in the server (via encryption functions).
    Data-at-rest tablespace encryption is available in MySQL 5.7 and higher.
[g] Implemented in the server, rather than in the storage engine.
[h] Implemented in the server, rather than in the storage engine.



下面将重点介绍最常使用的 4 种存储引擎： MyISAM、 InnoDB、 MEMORY 和 MERGE
NDB存储引擎会在第 33 章 MySQL CLUSTER 中详细介绍，这里不再赘述


7.2.1 MyISAM
1.MyISAM 是 MySQL5.5之前的默认存储引擎
2.MyISAM 不支持事务、也不支持外键
3.其优势是访问的速度快，对事务完整性没有要求或者以 SELECT、INSERT 为主的应用基本上都可以使用这个引擎来创建表
4.每个 MyISAM 在磁盘上存储成 3 个文件，其文件名都和表名相同，但扩展名分别是：
 .frm (存储表定义)
 .MYD (MYData，存储数据)
 .MYI (MYIndex，存储索引)

  实验:
  root@localhost[test] >CREATE TABLE `ai2` (   `i` bigint(20) NOT NULL AUTO_INCREMENT,   PRIMARY KEY (`i`) ) ENGINE=MyISAM DEFAULT CHARSET=gbk;
  Query OK, 0 rows affected (0.01 sec)

  $ ll /mysqldata/inst1/mydata/test/
    -rw-r----- 1 mysql mysql  8554 Jan 17 11:12 ai2.frm
    -rw-r----- 1 mysql mysql     0 Jan 17 11:12 ai2.MYD
    -rw-r----- 1 mysql mysql  1024 Jan 17 11:12 ai2.MYI

5.数据文件和索引文件可以放置在不同的目录，平均分布 IO，获得更快的速度
   a.要指定索引文件和数据文件的路径，需要在创建表的时候通过 DATA DIRECTORY 和 INDEXDIRECTORY 语句指定，
   b.也就是说不同 MyISAM 表的索引文件和数据文件可以放置到不同的路径下
   c.文件路径需要是绝对路径，并且具有访问权限

6.MyISAM 类型的表可能会损坏，原因可能是多种多样的，损坏后的表可能不能访问，会提示需要修复或者访问后返回错误的结果
   a.MyISAM 类型的表提供修复的工具,可以用 CHECKTABLE 语句来检查 MyISAM 表的健康
   b.并用 REPAIR TABLE 语句修复一个损坏的 MyISAM 表
   c.表损坏可能导致数据库异常重新启动，需要尽快修复并尽可能地确认损坏的原因
   d.具体的操作步骤可以参见第 35 章应急处理

7.MyISAM 的表支持 3 种不同的存储格式，分别是：
  a.静态（固定长度）表
  b.动态表
  c.压缩表

   其中，静态表是默认的存储格式:
   1.静态表中的字段都是非变长字段,这样每个记录都是固定长度的,这种存储方式的优点是存储非常迅速,容易缓存,出现故障容易恢复
   2.缺点是占用的空间通常比动态表多
   3.静态表的数据在存储的时候会按照列的宽度定义补足空格,但是在应用访问的时候并不会得到这些空格,这些空格在返回给应用之前已经去掉
   4.但是也有些需要特别注意的问题,如果需要保存的内容后面本来就带有空格,那么在返回结果的时候也会被去掉,
     开发人员在编写程序的时候需要特别注意，因为静态表是默认的存储格式，开发人员可能并没有意识到这一点，从而丢失了尾部的空格

以下例子演示了插入的记录包含空格时处理的情况：
root@localhost[test] >create table Myisam_char (name char(10)) engine=myisam;
Query OK, 0 rows affected (0.00 sec)

root@localhost[test] >insert into Myisam_char values('abcde'),('abcde  '),('  abcde'),('  abcde  ');
Query OK, 4 rows affected (0.01 sec)
Records: 4  Duplicates: 0  Warnings: 0

root@localhost[test] >select name,length(name) from Myisam_char;
+---------+--------------+
| name    | length(name) |
+---------+--------------+
| abcde   |            5 |
| abcde   |            5 |
|   abcde |            7 |
|   abcde |            7 |
+---------+--------------+
4 rows in set (0.00 sec)

从上面的例子可以看出，插入记录后面的空格都被去掉了，前面的空格保留


8.动态表
  动态表中包含变长字段，记录不是固定长度的，这样存储的优点是占用的空间相对较少，但是频繁地更新删除记录会产生碎片，
  需要定期执行 OPTIMIZE TABLE 语句或 myisamchk -r 命令来改善性能，并且出现故障的时候恢复相对比较困难


9.压缩表
  压缩表由 myisampack 工具创建，占据非常小的磁盘空间。因为每个记录是被单独压缩的,所以只有非常小的访问开支



7.2.2 InnoDB
  InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全
  但是对比 MyISAM的存储引擎，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引


下面将重点介绍 InnoDB 存储引擎的表使用过程中不同于其它存储引擎的特点:

1、自动增长列
InnoDB 表的自动增长列可以手工插入，但是插入的值如果是空或者 0，则实际插入的将是自动增长后的值

下面定义新表 autoincre_demo，其中列 i 使用自动增长列，对该表插入记录，然后查看自动增长列的处理情况，
可以发现插入 0 或者空 实际插入的都将是自动增长后的值：

a.插入的第一个值是非0非空情况
root@localhost[test] >create table autoincre_demo (
    -> i smallint not null auto_increment,
    -> name varchar(10),primary key(i)
    -> ) engine=innodb;
Query OK, 0 rows affected (0.03 sec)

root@localhost[test] >desc autoincre_demo;
+-------+-------------+------+-----+---------+----------------+
| Field | Type        | Null | Key | Default | Extra          |
+-------+-------------+------+-----+---------+----------------+
| i     | smallint(6) | NO   | PRI | NULL    | auto_increment |
| name  | varchar(10) | YES  |     | NULL    |                |
+-------+-------------+------+-----+---------+----------------+
2 rows in set (0.00 sec)

root@localhost[test] >insert into autoincre_demo values(1,'1'),(0,'2'),(null,'3');
Query OK, 3 rows affected (0.03 sec)
Records: 3  Duplicates: 0  Warnings: 0

root@localhost[test] >select * from autoincre_demo;
+---+------+
| i | name |
+---+------+
| 1 | 1    |
| 2 | 2    |
| 3 | 3    |
+---+------+
3 rows in set (0.00 sec)


b.插入的第一个值是0情况
root@localhost[test] >drop table autoincre_demo;   
Query OK, 0 rows affected (0.01 sec)

root@localhost[test] >create table autoincre_demo (i smallint not null auto_increment,name varchar(10),primary key(i)) engine=innodb;                        
Query OK, 0 rows affected (0.02 sec)

root@localhost[test] >select * from autoincre_demo;                
Empty set (0.00 sec)

root@localhost[test] >insert into autoincre_demo values(0,'1'),(0,'2'),(null,'3');
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

root@localhost[test] >select * from autoincre_demo;                               
+---+------+
| i | name |
+---+------+
| 1 | 1    |
| 2 | 2    |
| 3 | 3    |
+---+------+
3 rows in set (0.00 sec)


c.插入的第一个值是null的情况
root@localhost[test] >drop table autoincre_demo;                
Query OK, 0 rows affected (0.01 sec)

root@localhost[test] >create table autoincre_demo (i smallint not null auto_increment,name varchar(10),primary key(i)) engine=innodb;
Query OK, 0 rows affected (0.02 sec)

root@localhost[test] >insert into autoincre_demo values(null,'1'),(0,'2'),(null,'3');
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

root@localhost[test] >select * from autoincre_demo;
+---+------+
| i | name |
+---+------+
| 1 | 1    |
| 2 | 2    |
| 3 | 3    |
+---+------+
3 rows in set (0.00 sec)


c.可以通过“ALTER TABLE *** AUTO_INCREMENT = n;”语句强制设置自动增长列的初识值，默认从 1 开始，
  但是该强制的默认值是保留在内存中的,如果该值在使用之前数据库重新启动,那么这个强制的默认值就会丢失,就需要在数据库启动以后重新设置


d.可以使用 LAST_INSERT_ID()查询当前线程最后插入记录使用的值
  如果一次插入了多条记录,那么返回的是第一条记录使用的自动增长值

下面的例子演示了使用 LAST_INSERT_ID()的情况：
root@localhost[test] >select last_insert_id();
+------------------+
| last_insert_id() |
+------------------+
|                1 |
+------------------+
1 row in set (0.00 sec)

root@localhost[test] >insert into autoincre_demo values(null,'1'),(0,'2'),(null,'3');
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

root@localhost[test] >select last_insert_id();                                       
+------------------+
| last_insert_id() |
+------------------+
|                4 |
+------------------+
1 row in set (0.00 sec)


索引:
1.对于 InnoDB 表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列，
2.但是对于 MyISAM 表，自动增长列可以是组合索引的其它列，这样插入记录后，自动增长列是按照组合索引的前面几列进行排序后递增的

例如，创建一个新的 MyISAM 类型的表autoincre_demo，自动增长列 d1 作为组合索引的第二列，对该表插入一些记录后，
      可以发现自动增长列是按照组合索引的第一列 d2 进行排序后递增的:


root@localhost[test] >drop table autoincre_demo;
Query OK, 0 rows affected (0.00 sec)

root@localhost[test] >create table autoincre_demo
    -> (d1 smallint not null auto_increment,
    -> d2 smallint not null,
    -> name varchar(10),
    -> index(d2,d1)
    -> ) engine=myisam;
Query OK, 0 rows affected (0.02 sec)

root@localhost[test] >insert into autoincre_demo (d2,name) values(2,'2'),(3,'3'),(4,'4'),(2,'2'),(3,'3'),(4,'4');
Query OK, 6 rows affected (0.01 sec)
Records: 6  Duplicates: 0  Warnings: 0

root@localhost[test] >select * from autoincre_demo;
+----+----+------+
| d1 | d2 | name |
+----+----+------+
|  1 |  2 | 2    |
|  1 |  3 | 3    |
|  1 |  4 | 4    |
|  2 |  2 | 2    |
|  2 |  3 | 3    |
|  2 |  4 | 4    |
+----+----+------+
6 rows in set (0.00 sec)


2、外键约束
   MySQL 支持外键的存储引擎只有 InnoDB,在创建外键的时候,要求父表必须有对应的索引,子表在创建外键的时候也会自动创建对应的索引

下面是样例数据库中的两个表:
a.country 表是父表,country_id 为其主键索引
b.city 表是子表,其country_id 字段对 country 表的 country_id 有外键


root@localhost[test] >create table country (country_id smallint unsigned not null auto_increment, country varchar(50) not null, last_update timestamp not null default current_timestamp on update current_timestamp, primary key (country_id) ) engine=innodb default charset=utf8;
Query OK, 0 rows affected (0.02 sec)

root@localhost[test] >desc country;
+-------------+----------------------+------+-----+-------------------+-----------------------------+
| Field       | Type                 | Null | Key | Default           | Extra                       |
+-------------+----------------------+------+-----+-------------------+-----------------------------+
| country_id  | smallint(5) unsigned | NO   | PRI | NULL              | auto_increment              |
| country     | varchar(50)          | NO   |     | NULL              |                             |
| last_update | timestamp            | NO   |     | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |
+-------------+----------------------+------+-----+-------------------+-----------------------------+
3 rows in set (0.00 sec)


## 创建外键
http://dev.mysql.com/doc/refman/5.7/en/create-table-foreign-keys.html

[CONSTRAINT [symbol]] FOREIGN KEY
    [index_name] (index_col_name, ...)
    REFERENCES tbl_name (index_col_name,...)
    [ON DELETE reference_option]
    [ON UPDATE reference_option]

reference_option:
    RESTRICT | CASCADE | SET NULL | NO ACTION



create table city
(city_id smallint unsigned not null auto_increment,
city varchar(50) not null,
country_id smallint unsigned not null,
last_update timestamp not null default current_timestamp on update current_timestamp,
primary key (city_id),
key idx_fk_country_id (country_id),
constraint `fk_city_country` foreign key (country_id) references country (country_id) on delete restrict on update cascade
) engine=innodb default charset=utf8;
Query OK, 0 rows affected (0.02 sec)


mysql> create table city (city_id smallint unsigned not null auto_increment, city varchar(50) not null, country_id smallint unsigned not null, last_update timestamp not null default current_timestamp on update current_timestamp, primary key (city_id), key idx_fk_country_id (country_id), constraint `fk_city_country` foreign key (country_id) references country (country_id) on delete restrict on update cascade ) engine=innodb default charset=utf8;
Query OK, 0 rows affected (0.02 sec)




root@localhost[test] >desc city;
+-------------+----------------------+------+-----+-------------------+-----------------------------+
| Field       | Type                 | Null | Key | Default           | Extra                       |
+-------------+----------------------+------+-----+-------------------+-----------------------------+
| city_id     | smallint(5) unsigned | NO   | PRI | NULL              | auto_increment              |
| city        | varchar(50)          | NO   |     | NULL              |                             |
| country_id  | smallint(5) unsigned | NO   | MUL | NULL              |                             |
| last_update | timestamp            | NO   |     | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |
+-------------+----------------------+------+-----+-------------------+-----------------------------+
4 rows in set (0.00 sec)


a.在创建索引的时候，可以指定在删除、 更新父表时，对子表进行的相应操作:包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION
b.其中 RESTRICT 和 NO ACTION 相同，是指限制在与子表有关联记录的情况下父表不能更新
c.CASCADE 表示父表在更新或者删除时，更新或者删除子表对应记录
d.SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被 SET NULL
e.选择后两种方式的时候要谨慎，可能会因为错误的操作导致数据的丢失


例如,对上面创建的两个表，子表的外键指定是 ON DELETE RESTRICT ON UPDATE CASCADE方式的，
     1.ON DELETE RESTRICT  在主表删除记录的时候，如果子表有对应记录，则不允许删除
     2.ON UPDATE CASCADE   主表在更新记录的时候，如果子表有对应记录，则子表对应更新

root@localhost[test] >select * from country;
Empty set (0.00 sec)

root@localhost[test] >select * from city;   
Empty set (0.00 sec)

root@localhost[test] >insert into country (country,last_update) values ('Afghanistan','2017-01-17 14:45:00');
Query OK, 1 row affected (0.00 sec)

root@localhost[test] >select * from country;
+------------+-------------+---------------------+
| country_id | country     | last_update         |
+------------+-------------+---------------------+
|          1 | Afghanistan | 2017-01-17 14:45:00 |
+------------+-------------+---------------------+
1 row in set (0.01 sec)

root@localhost[test] >select * from city;
Empty set (0.00 sec)

root@localhost[test] >insert into city (city,last_update) values ('Kabul','2017-01-17 14:46:00');
ERROR 1364 (HY000): Field 'country_id' doesn't have a default value

root@localhost[test] >insert into city (city,country_id,last_update) values ('Kabul',1,'2017-01-17 14:46:00');
Query OK, 1 row affected (0.01 sec)

root@localhost[test] >select * from city;
+---------+-------+------------+---------------------+
| city_id | city  | country_id | last_update         |
+---------+-------+------------+---------------------+
|       1 | Kabul |          1 | 2017-01-17 14:46:00 |
+---------+-------+------------+---------------------+
1 row in set (0.00 sec)


## delete  ON DELETE RESTRICT
root@localhost[test] >select * from country where country_id=1;
+------------+-------------+---------------------+
| country_id | country     | last_update         |
+------------+-------------+---------------------+
|          1 | Afghanistan | 2017-01-17 14:45:00 |
+------------+-------------+---------------------+
1 row in set (0.00 sec)

root@localhost[test] >select * from city where country_id=1;             
+---------+-------+------------+---------------------+
| city_id | city  | country_id | last_update         |
+---------+-------+------------+---------------------+
|       1 | Kabul |          1 | 2017-01-17 14:46:00 |
+---------+-------+------------+---------------------+
1 row in set (0.00 sec)

root@localhost[test] >delete from country where country_id=1;        
ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`test`.`city`, CONSTRAINT `fk_city_country` FOREIGN KEY (`country_id`) REFERENCES `country` (`country_id`) ON UPDATE CASCADE)



## update   ON UPDATE CASCADE 
root@localhost[test] >update country set country_id=1000 where country_id=1;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

root@localhost[test] >select * from country;                   
+------------+-------------+---------------------+
| country_id | country     | last_update         |
+------------+-------------+---------------------+
|       1000 | Afghanistan | 2017-01-17 14:47:54 |
+------------+-------------+---------------------+
1 row in set (0.00 sec)

root@localhost[test] >select * from city;                                   
+---------+-------+------------+---------------------+
| city_id | city  | country_id | last_update         |
+---------+-------+------------+---------------------+
|       1 | Kabul |       1000 | 2017-01-17 14:46:00 |
+---------+-------+------------+---------------------+
1 row in set (0.00 sec)


1.当某个表被其它表创建了外键参照，那么该表的对应索引或者主键禁止被删除
2.在导入多个表的数据时，如果需要忽略表之前的导入顺序，可以暂时关闭外键的检查
3.同样，在执行 LOAD DATA 和 ALTER TABLE 操作的时候，可以通过暂时关闭外键约束来加快处理的速度
  关闭的命令是"SET FOREIGN_KEY_CHECKS = 0;", 执行完成之后,通过执行"SETFOREIGN_KEY_CHECKS = 1;"语句改回原状态
4.对于 InnoDB 类型的表, 外键的信息通过使用 show create table 或者 show table status 命令都可以显示



3、存储方式
InnoDB 存储表和索引有以下两种方式:
  a.使用共享表空间存储
     1.这种方式创建的表的表结构保存在.frm 文件中,
     2.数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中,可以是多个文件

  b.使用多表空间存储
     1.这种方式创建的表的表结构仍然保存在.frm 文件中，但是每个表的数据和索引单独保存在.ibd 中
     2.如果是个分区表，则每个分区对应单独的.ibd文件，文件名是“表名+分区名”
     3.可以在创建分区的时候指定每个分区的数据文件的位置，以此来将表的 IO 均匀分布在多个磁盘上
     4.要使用多表空间的存储方式，需要设置参数 innodb_file_per_table，并重新启动服务后才可以生效
     5.对于新建的表按照多表空间的方式创建，已有的表仍然使用共享表空间存储
     6.如果将已有的多表空间方式修改回共享表空间的方式，则新建表会在共享表空间中创建,但已有的多表空间的表仍然保存原来的访问方式
     7.所以多表空间的参数生效后，只对新建的表生效
     8.多表空间的数据文件没有大小限制，不需要设置初始大小，也不需要设置文件的最大限制、扩展大小等参数
     9.对于使用多表空间特性的表，可以比较方便地进行单表备份和恢复操作，但是直接复制.ibd 文件是不行的，
       因为没有共享表空间的数据字典信息，直接复制的.ibd 文件和.frm 文件恢复时是不能被正确识别的，但可以通过以下命令：
       ALTER TABLE tbl_name DISCARD TABLESPACE;
       ALTER TABLE tbl_name IMPORT TABLESPACE;
     10.将备份恢复到数据库中，但是这样的单表备份，只能恢复到表原来在的数据库中，而不能恢复到其它的数据库中
     11.如果要将单表恢复到目标数据库，则需要通过 mysqldump 和 mysqlimport 来实现
     12.注意：即便在多表空间的存储方式下，共享表空间仍然是必须的，InnoDB 把内部数据词典和未作日志放在这个文件中




7.2.3 MEMORY
  a.MEMORY 存储引擎使用存在内存中的内容来创建表
  b.每个 MEMORY 表只实际对应一个磁盘文件，格式是.frm
  c.MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的,并且默认使用 HASH 索引,但是一旦服务关闭,表中的数据就会丢失掉

下面例子创建了一个 MEMORY 的表,并从 city 表获得记录：
root@localhost[test] >create table tab2_memory engine=memory select city_id,city,country_id from city group by city_id;
Query OK, 1 row affected (0.01 sec)
Records: 1  Duplicates: 0  Warnings: 0

root@localhost[test] >desc tab2_memory;
+------------+----------------------+------+-----+---------+-------+
| Field      | Type                 | Null | Key | Default | Extra |
+------------+----------------------+------+-----+---------+-------+
| city_id    | smallint(5) unsigned | NO   |     | 0       |       |
| city       | varchar(50)          | NO   |     | NULL    |       |
| country_id | smallint(5) unsigned | NO   |     | NULL    |       |
+------------+----------------------+------+-----+---------+-------+
3 rows in set (0.00 sec)

root@localhost[test] >select * from tab2_memory;
+---------+-------+------------+
| city_id | city  | country_id |
+---------+-------+------------+
|       1 | Kabul |       1000 |
+---------+-------+------------+
1 row in set (0.00 sec)

root@localhost[test] >show table status like 'tab2_memory'\G
*************************** 1. row ***************************
           Name: tab2_memory
         Engine: MEMORY
        Version: 10
     Row_format: Fixed
           Rows: 1
 Avg_row_length: 155
    Data_length: 8320
Max_data_length: 16252835
   Index_length: 0
      Data_free: 0
 Auto_increment: NULL
    Create_time: 2017-01-17 16:46:38
    Update_time: NULL
     Check_time: NULL
      Collation: utf8_bin
       Checksum: NULL
 Create_options: 
        Comment: 
1 row in set (0.00 sec)


给 MEMORY 表创建索引的时候，可以指定使用 HASH 索引还是 BTREE 索引：

## hash index
root@localhost[test] >create index mem_hash using hash on tab2_memory (city_id);
Query OK, 1 row affected (0.01 sec)
Records: 1  Duplicates: 0  Warnings: 0

root@localhost[test] >show index from tab2_memory\G
*************************** 1. row ***************************
        Table: tab2_memory
   Non_unique: 1
     Key_name: mem_hash
 Seq_in_index: 1
  Column_name: city_id
    Collation: NULL
  Cardinality: 1
     Sub_part: NULL
       Packed: NULL
         Null: 
   Index_type: HASH
      Comment: 
Index_comment: 
1 row in set (0.00 sec)


## btree index
root@localhost[test] >drop index mem_hash on tab2_memory;
Query OK, 1 row affected (0.01 sec)
Records: 1  Duplicates: 0  Warnings: 0

root@localhost[test] >create index mem_hash using btree on tab2_memory (city_id); 
Query OK, 1 row affected (0.02 sec)
Records: 1  Duplicates: 0  Warnings: 0

root@localhost[test] >show index from tab2_memory\G
*************************** 1. row ***************************
        Table: tab2_memory
   Non_unique: 1
     Key_name: mem_hash
 Seq_in_index: 1
  Column_name: city_id
    Collation: A
  Cardinality: NULL
     Sub_part: NULL
       Packed: NULL
         Null: 
   Index_type: BTREE
      Comment: 
Index_comment: 
1 row in set (0.00 sec)


a.在启动 MySQL 服务的时候使用--init-file 选项，把 INSERT INTO ... SELECT 或 LOAD DATA INFILE 这样的语句放入这个文件中，
  就可以在服务启动时从持久稳固的数据源装载表
b.服务器需要足够内存来维持所有在同一时间使用的 MEMORY 表,当不再需要 MEMORY表的内容之时,要释放被 MEMORY 表使用的内存,
  应该执行 DELETE FROM 或 TRUNCATE TABLE，或者整个地删除表（使用 DROP TABLE 操作）
c.每个 MEMORY 表中可以放置的数据量的大小,受到 max_heap_table_size 系统变量的约束,这个系统变量的初始值是 16MB,可以按照需要加大
d.在定义 MEMORY 表的时候，可以通过 MAX_ROWS 子句指定表的最大行数
e.MEMORY 类型的存储引擎主要用在那些内容变化不频繁的代码表，或者作为统计操作的中间结果表，
  便于高效地对中间结果进行分析并得到最终的统计结果
f.对 MEMORY 存储引擎的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新
  启动服务后如何获得这些修改后的数据有所考虑




7.2.4 MERGE
1.MERGE 存储引擎是一组 MyISAM 表的组合，这些 MyISAM 表必须结构完全相同
2.MERGE表本身并没有数据，对 MERGE 类型的表可以进行查询、更新、删除的操作，这些操作实际上是对内部的实际的 MyISAM 表进行的
3.对于 MERGE 类型表的插入操作，是通过INSERT_METHOD 子句定义插入的表，可以有 3 个不同的值，
  a.使用 FIRST 或 LAST 值使得插入操作被相应地作用在第一或最后一个表上，
  b.不定义这个子句或者定义为 NO，表示不能对这个 MERGE 表执行插入操作
4.可以对 MERGE 表进行 DROP 操作，这个操作只是删除 MERGE 的定义，对内部的表没有任何的影响
5.MERGE 表在磁盘上保留两个文件,文件名以表的名字开始，一个.frm 文件存储表定义，
  另一个.MRG 文件包含组合表的信息，包括 MERGE 表由哪些表组成、 插入新的数据时的依据
6.可以通过修改.MRG 文件来修改 MERGE 表，但是修改后要通过 FLUSH TABLES 刷新


下面是一个创建和使用 MERGE 表的例子

（1）创建 3 个测试表 payment_2016、payment_2017 和 payment_all，其中 payment_all是前两个表的 MERGE 表：
root@localhost[test] >create table payment_2016 (country_id smallint, payment_date datetime, amount decimal(15,2), key idx_fk_country_id (country_id) ) engine=myisam;                                    
Query OK, 0 rows affected (0.01 sec)

root@localhost[test] >create table payment_2017 (country_id smallint, payment_date datetime, amount decimal(15,2), key idx_fk_country_id (country_id) ) engine=myisam; 
Query OK, 0 rows affected (0.00 sec)

root@localhost[test] >create table payment_all (country_id smallint, payment_date datetime, amount decimal(15,2), index (country_id) ) engine=merge union=(payment_2016,payment_2017) insert_method=last;
Query OK, 0 rows affected (0.01 sec)

root@localhost[test] >insert into payment_2016 values(1,'2016-05-01',100000),(2,'2016-08-01',150000);
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

root@localhost[test] >select * from payment_all;
+------------+---------------------+-----------+
| country_id | payment_date        | amount    |
+------------+---------------------+-----------+
|          1 | 2016-05-01 00:00:00 | 100000.00 |
|          2 | 2016-08-01 00:00:00 | 150000.00 |
+------------+---------------------+-----------+
2 rows in set (0.00 sec)

root@localhost[test] >insert into payment_2017 values(1,'2017-05-01',35000),(2,'2017-08-01',220000);
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

root@localhost[test] >select * from payment_all;                                                    
+------------+---------------------+-----------+
| country_id | payment_date        | amount    |
+------------+---------------------+-----------+
|          1 | 2016-05-01 00:00:00 | 100000.00 |
|          2 | 2016-08-01 00:00:00 | 150000.00 |
|          1 | 2017-05-01 00:00:00 |  35000.00 |
|          2 | 2017-08-01 00:00:00 | 220000.00 |
+------------+---------------------+-----------+
4 rows in set (0.00 sec)



root@localhost[test] >select * from payment_2016;
+------------+---------------------+-----------+
| country_id | payment_date        | amount    |
+------------+---------------------+-----------+
|          1 | 2016-05-01 00:00:00 | 100000.00 |
|          2 | 2016-08-01 00:00:00 | 150000.00 |
+------------+---------------------+-----------+
2 rows in set (0.00 sec)

root@localhost[test] >select * from payment_2017;
+------------+---------------------+-----------+
| country_id | payment_date        | amount    |
+------------+---------------------+-----------+
|          1 | 2017-05-01 00:00:00 |  35000.00 |
|          2 | 2017-08-01 00:00:00 | 220000.00 |
+------------+---------------------+-----------+
2 rows in set (0.01 sec)


可以发现，payment_all 表中的数据是 payment_2016 和 payment_2017 表的记录合并后的结果集


下面向 MERGE 表插入一条记录，由于 MERGE 表的定义是 INSERT_METHOD=LAST，就会向最
后一个表中插入记录，所以虽然这里插入的记录是 2016 年的，但仍然会写到 payment_2017表中

root@localhost[test] >desc payment_all;
+--------------+---------------+------+-----+---------+-------+
| Field        | Type          | Null | Key | Default | Extra |
+--------------+---------------+------+-----+---------+-------+
| country_id   | smallint(6)   | YES  | MUL | NULL    |       |
| payment_date | datetime      | YES  |     | NULL    |       |
| amount       | decimal(15,2) | YES  |     | NULL    |       |
+--------------+---------------+------+-----+---------+-------+
3 rows in set (0.00 sec)

root@localhost[test] >insert into payment_all values(3,'2016-03-31',112200);
Query OK, 1 row affected (0.00 sec)

root@localhost[test] >select * from payment_all;
+------------+---------------------+-----------+
| country_id | payment_date        | amount    |
+------------+---------------------+-----------+
|          1 | 2016-05-01 00:00:00 | 100000.00 |
|          2 | 2016-08-01 00:00:00 | 150000.00 |
|          1 | 2017-05-01 00:00:00 |  35000.00 |
|          2 | 2017-08-01 00:00:00 | 220000.00 |
|          3 | 2016-03-31 00:00:00 | 112200.00 |
+------------+---------------------+-----------+
5 rows in set (0.00 sec)

root@localhost[test] >select * from payment_2016;
+------------+---------------------+-----------+
| country_id | payment_date        | amount    |
+------------+---------------------+-----------+
|          1 | 2016-05-01 00:00:00 | 100000.00 |
|          2 | 2016-08-01 00:00:00 | 150000.00 |
+------------+---------------------+-----------+
2 rows in set (0.00 sec)

root@localhost[test] >select * from payment_2017;
+------------+---------------------+-----------+
| country_id | payment_date        | amount    |
+------------+---------------------+-----------+
|          1 | 2017-05-01 00:00:00 |  35000.00 |
|          2 | 2017-08-01 00:00:00 | 220000.00 |
|          3 | 2016-03-31 00:00:00 | 112200.00 |
+------------+---------------------+-----------+
3 rows in set (0.00 sec)


这也是 MERGE 表和分区表的区别，MERGE 表并不能智能地将记录写到对应的表中，而分区表是可以的（分区功能在 5.1 版中正式推出）
通常我们使用 MERGE 表来透明地对多个表进行查询和更新操作，而对这种按照时间记录的操作日志表则可以透明地进行插入操作



7.3 如何选择合适的存储引擎

在选择存储引擎时，应根据应用特点选择合适的存储引擎，对于复杂的应用系统可以根据实际情况选择多种存储引擎进行组合

下面是常用存储引擎的适用环境:
   MyISAM：默认的 MySQL5.5前版本 插件式存储引擎
            1.如果应用是以读操作和插入操作为主,只有很少的更新和删除操作,并且对事务的完整性、并发性要求不是很高,
              那么选择这个存储引擎是非常适合的
            2.MyISAM 是在 web、数据仓储和其它应用环境下最常使用的存储引擎之一


   InnoDB：用于事务处理应用程序，支持外键
            1.如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，
              还包括很多的更新、删除操作，那么 InnoDB 存储引擎应该是比较合适的选择
            2.InnoDB 存储引擎除了有效地降低由于删除和更新导致的锁定，还可以确保事务的完整提交（Commit）和回滚（Rollback），
              对于类似计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB 都是合适的选择


   MEMORY：将所有数据保存在 RAM 中，在需要快速定位记录和其他类似数据的环境下，可提供极快的访问
            1.MEMORY 的缺陷是对表的大小有限制，太大的表无法 CACHE 在内存中
            2.其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的
            3.MEMORY 表通常用于更新不太频繁的小表，用以快速得到访问结果


   MERGE：用于将一系列等同的 MyISAM 表以逻辑方式组合在一起，并作为一个对象引用它们
           1.MERGE 表的优点在于可以突破对单个 MyISAM 表大小的限制,并且通过将不同的表分布在多个磁盘上,
             可以有效地改善 MERGE 表的访问效率。 这对于诸如数据仓储等 VLDB 环境十分适合


    注意：以上只是我们按照实施经验提出的关于存储引擎选择的一些建议，但是不同应用的特点是千差万别的，
          选择使用哪种存储引擎才是最佳方案也不是绝对的，这需要根据用户各自的应用进行测试，从而得到最适合自己的结果




7.4 小结

本章重点介绍了 MySQL 提供的几种主要的存储引擎及其使用、特性，以及如何根据应用的需要选择合适的存储引擎
这些提供的存储引擎有各自的优势和适用的场合，正确地选择存储引擎对改善应用的效率可以起到事半功倍的效果
正确地选择了存储引擎之后，还需要正确选择表中的数据类型，下一章我们将详细介绍如何选择合适的数据类型
