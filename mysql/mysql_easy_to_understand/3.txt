第3章 MySQL 支持的数据类型


每一个常量，变量和参数都有数据类型，它用来指定一定的存储格式、约束和有效范围。
MySQL 提供了多种数据类型， 主要包括数值型、 字符串类型、 日期和时间类型
不同的 MySQL版本支持的数据类型可能会稍有不同， 用户可以通过查询相应版本的帮助文件来获得具体信息
本章将以 MySQL 5.0 为例，详细介绍 MySQL 中的各种数据类型


3.1 数值类型
MySQL 支持所有标准 SQL 中的数值类型,其中包括严格数值类型(INTEGER、SMALLINT、DECIMAL 和 NUMERIC)以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION),并在此基础上做了扩展
扩展后增加了 TINYINT、MEDIUMINT 和 BIGINT 这 3 种长度不同的整型，并增加了 BIT 类型，用来存放位数据


表 3-1 中列出了 MySQL 5.0 中支持的所有数值类型，其中 INT 是 INTEGER 的同名词，DEC 是 DECIMAL 的同名词

MySQL 中的数值类型
整数类型       字节    最小值				      最大值
TINYINT        1       有符号-128 无符号 0		      有符号 127 无符号 255
SMALLINT       2       有符号-32768 无符号 0		      有符号 32767 无符号 65535
MEDIUMINT      3       有符号-8388608 无符号 0		      有符号 8388607 无符号 1677215
INT、INTEGER   4       有符号-2147483648 无符号 0	      有符号 2147483647 无符号 4294967295
BIGINT         8       有符号-9223372036854775808 无符号 0    有符号 9223372036854775807 无符号 18446744073709551615


浮点数类型    字节     最小值                     最大值
FLOAT         4        ±1.175494351E-38           ±3.402823466E+38
DOUBLE        8        ±2.2250738585072014E-308   ±1.7976931348623157E+308


定点数类型              字节       描述
DEC(M,D),DECIMAL(M,D)   M+2        最大取值范围与DOUBLE相同,给定DECIMAL的有效取值范围由M和D决定,如,decimal(10,2)


位类型       字节       最小值     最大值
BIT(M)       1～8       BIT(1)     BIT(64)



在整数类型中，按照取值范围和存储方式不同，分为 tinyint、smallint、mediumint、int、bigint 这 5 个类型
如果超出类型范围的操作，会发生“Out of range”错误提示
为了避免此类问题发生，在选择数据类型时要根据应用的实际情况确定其取值范围，最后根据确定的结果慎重选择数据类型

对于整型数据，MySQL还支持在类型名称后面的小括号内指定显示宽度:
例如, int(5)表示当数值宽度小于 5 位的时候在数字前面填满宽度，如果不显示指定宽度则默认为 int(11)

一般配合 zerofill 使用，顾名思义，zerofill 就是用“0”填充的意思，也就是在数字位数不够的空间用字符“0”填满

以下几个例子分别描述了填充前后的区别:
（1）创建表 t1，有 id1 和 id2 两个字段，指定其数值宽度分别为 int 和 int(5)
mysql> use test1;
Database changed
mysql> create table t1(id1 int, id2 int(5)); 
Query OK, 0 rows affected (0.03 sec)


当int不是无符号unsigned时,int默认长度为11
mysql> desc t1;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| id1   | int(11) | YES  |     | NULL    |       |
| id2   | int(5)  | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
2 rows in set (0.00 sec)


（2）在 id1 和 id2 中都插入数值 1，可以发现格式没有异常:
mysql> insert into t1 values(1,1);
Query OK, 1 row affected (0.00 sec)

mysql> select * from t1;
+------+------+
| id1  | id2  |
+------+------+
|    1 |    1 |
+------+------+
1 row in set (0.00 sec)


（3）分别修改 id1 和 id2 的字段类型，加入 zerofill 参数：
当int是无符号unsigned时,int默认长度为10, zerofill用于填充0

mysql> alter table t1 modify id1 int zerofill;
Query OK, 1 row affected (0.03 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql> alter table t1 modify id2 int(5) zerofill;
Query OK, 1 row affected (0.03 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql> desc t1;
+-------+---------------------------+------+-----+---------+-------+
| Field | Type                      | Null | Key | Default | Extra |
+-------+---------------------------+------+-----+---------+-------+
| id1   | int(10) unsigned zerofill | YES  |     | NULL    |       |
| id2   | int(5) unsigned zerofill  | YES  |     | NULL    |       |
+-------+---------------------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

mysql> select * from t1;
+------------+-------+
| id1        | id2   |
+------------+-------+
| 0000000001 | 00001 |
+------------+-------+
1 row in set (0.00 sec)


可以发现，在数值前面用字符“0”填充了剩余的宽度

大家可能会有所疑问，设置了宽度限制后，如果插入大于宽度限制的值，会不会截断或者插不进去报错？
答案是肯定的：不会对插入的数据有任何影响，还是按照类型的实际精度进行保存
这时，宽度格式实际已经没有意义，左边不会再填充任何的“0”字符

下面在表t1的字段 id1 中插入数值 1，id2 中插入数值 1111111，位数为 7，大于 id2 的显示位数 5，再观察一下测试结果：
ql> desc t1;
+-------+---------------------------+------+-----+---------+-------+
| Field | Type                      | Null | Key | Default | Extra |
+-------+---------------------------+------+-----+---------+-------+
| id1   | int(10) unsigned zerofill | YES  |     | NULL    |       |
| id2   | int(5) unsigned zerofill  | YES  |     | NULL    |       |
+-------+---------------------------+------+-----+---------+-------+
2 rows in set (0.01 sec)

mysql> select * from t1;
+------------+-------+
| id1        | id2   |
+------------+-------+
| 0000000001 | 00001 |
+------------+-------+
1 row in set (0.00 sec)

mysql> insert into t1 values(1,1111111);
Query OK, 1 row affected (0.01 sec)

mysql> select * from t1;                
+------------+---------+
| id1        | id2     |
+------------+---------+
| 0000000001 |   00001 |
| 0000000001 | 1111111 |
+------------+---------+
2 rows in set (0.00 sec)

很显然，如上面所说，id2 中显示了正确的数值，并没有受宽度限制影响


整数类型之UNSIGNED（无符号）正数:
1.所有的整数类型都有一个可选属性 UNSIGNED（无符号）,
  如果需要在字段里面保存非负数或者需要较大的上限值时，可以用此选项

2.它的取值范围是正常值的下限取 0，上限取原值的 2 倍,
  例如，tinyint 有符号范围是-128～+127，而无符号范围是 0～255

3.有符号和无符号怎么理解？
  正负数,有符号是负数,无符号是正数,如果为正数是无法插入负数数据:
        mysql> select * from t1;
	+------------+---------+
	| id1        | id2     |
	+------------+---------+
	| 0000000001 |   00001 |
	| 0000000001 | 1111111 |
	+------------+---------+
	2 rows in set (0.00 sec)

	mysql> insert into t1 values(-123,-111);
	ERROR 1264 (22003): Out of range value for column 'id1' at row 1
	mysql> 
	mysql> insert into t1 values(-1,-111);  
	ERROR 1264 (22003): Out of range value for column 'id1' at row 1
	mysql> 
	mysql> insert into t1 values(-1,-1);  
	ERROR 1264 (22003): Out of range value for column 'id1' at row 1


4.如果一个列指定为 zerofill，则 MySQL 自动为该列添加 UNSIGNED 属性


整数类型属性之： AUTO_INCREMENT
1.在需要产生唯一标识符或顺序值时，可利用此属性, 这个属性只用于整数类型
2.AUTO_INCREMENT值一般从 1 开始， 每行增加 1
3.在插入 NULL 到一个 AUTO_INCREMENT 列时，MySQL 插入一个比该列中当前最大值大 1 的值
4.一个表中最多只能有一个 AUTO_INCREMENT列
5.对于任何想要使用 AUTO_INCREMENT的列，应该定义为 NOT NULL，并定义为 PRIMARY KEY 或定义为 UNIQUE键

例如，可按下列任何一种方式定义AUTO_INCREMENT列:
ql> use test1;
Database changed
mysql> create table A1(ID INT AUTO_INCREMENT NOT NULL PRIMARY KEY);
Query OK, 0 rows affected (0.03 sec)

mysql> create table A2(ID INT AUTO_INCREMENT NOT NULL, PRIMARY KEY(ID));
Query OK, 0 rows affected (0.02 sec)

mysql> create table A3(ID INT AUTO_INCREMENT NOT NULL, UNIQUE(ID));      
Query OK, 0 rows affected (0.02 sec)

mysql> desc A1;
+-------+---------+------+-----+---------+----------------+
| Field | Type    | Null | Key | Default | Extra          |
+-------+---------+------+-----+---------+----------------+
| ID    | int(11) | NO   | PRI | NULL    | auto_increment |
+-------+---------+------+-----+---------+----------------+
1 row in set (0.00 sec)

mysql> desc A2;
+-------+---------+------+-----+---------+----------------+
| Field | Type    | Null | Key | Default | Extra          |
+-------+---------+------+-----+---------+----------------+
| ID    | int(11) | NO   | PRI | NULL    | auto_increment |
+-------+---------+------+-----+---------+----------------+
1 row in set (0.00 sec)

mysql> desc A3;
+-------+---------+------+-----+---------+----------------+
| Field | Type    | Null | Key | Default | Extra          |
+-------+---------+------+-----+---------+----------------+
| ID    | int(11) | NO   | PRI | NULL    | auto_increment |
+-------+---------+------+-----+---------+----------------+
1 row in set (0.00 sec)



对于小数的表示，MySQL 分为两种方式：浮点数和定点数
浮点数包括 float（单精度）和 double（双精度）

定点数则只有 decimal 一种表示
定点数在 MySQL 内部以字符串形式存放，比浮点数更精确，适合用来表示货币等精度高的数据

浮点数和定点数都可以用类型名称后加“(M,D)”的方式来进行表示:
“(M,D)”表示该值一共显示 M 位数字（整数位+小数位）,其中 D 位位于小数点后面，M 和 D 又称为精度和标度

例如，定义为 float(7,4)的一个列可以显示为-999.9999。MySQL 保存值时进行四舍五入，因此如果在 float(7,4)列内插入 999.00009，近似结果是 999.0001

值得注意的是，浮点数后面跟“(M,D)”的用法是非标准用法，如果要用于数据库的迁移，则最好不要这么使用

float 和 double 在不指定精度时，默认会按照实际的精度（由实际的硬件和操作系统决定）来显示
decimal 在不指定精度时，默认的整数位为 10，默认的小数位为 0

下面通过一个例子来比较 float、double 和 decimal 三者之间的不同:
（1） 创建测试表， 分别将 id1、 id2、 id3 字段设置为 float(5,2)、 double(5,2)、 decimal(5,2)
mysql> use test1;
Database changed

mysql> drop table t1;
Query OK, 0 rows affected (0.01 sec)

mysql> create table t1 (id1 float(5,2) default NULL, id2 double(5,2) default NULL, id3 decimal(5,2) default NUll);
Query OK, 0 rows affected (0.02 sec)

mysql> desc t1;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id1   | float(5,2)   | YES  |     | NULL    |       |
| id2   | double(5,2)  | YES  |     | NULL    |       |
| id3   | decimal(5,2) | YES  |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
3 rows in set (0.00 sec)


（2）往 id1、id2 和 id3 这 3 个字段中插入数据 1.23
ql> insert into t1 values(1.23, 1.23, 1.23);
Query OK, 1 row affected (0.01 sec)

mysql> select * from t1;
+------+------+------+
| id1  | id2  | id3  |
+------+------+------+
| 1.23 | 1.23 | 1.23 |
+------+------+------+
1 row in set (0.01 sec)

可以发现，数据都正确地插入了表 t1


（3）再向 id1 和 id2 字段中插入数据 1.234，而 id3 字段中仍然插入 1.23
mysql> insert into t1 values(1.234, 1.234, 1.23);
Query OK, 1 row affected (0.00 sec)

mysql> select * from t1;                         
+------+------+------+
| id1  | id2  | id3  |
+------+------+------+
| 1.23 | 1.23 | 1.23 |
| 1.23 | 1.23 | 1.23 |
+------+------+------+
2 rows in set (0.00 sec)

可以发现,id1、 id2、 id3 都插入了表 t1, 但是 id1 和 id2 由于标度的限制，舍去了最后一位，数据变为了1.23


（4）同时向 id1、id2、id3 字段中都插入数据 1.234
mysql> insert into t1 values(1.234, 1.234, 1.234);
Query OK, 1 row affected, 1 warning (0.01 sec)

mysql> show warnings;
+-------+------+------------------------------------------+
| Level | Code | Message                                  |
+-------+------+------------------------------------------+
| Note  | 1265 | Data truncated for column 'id3' at row 1 |
+-------+------+------------------------------------------+
1 row in set (0.00 sec)

mysql> select * from t1;
+------+------+------+
| id1  | id2  | id3  |
+------+------+------+
| 1.23 | 1.23 | 1.23 |
| 1.23 | 1.23 | 1.23 |
| 1.23 | 1.23 | 1.23 |
+------+------+------+
3 rows in set (0.00 sec)

此时发现，虽然数据都插入进去，但是系统出现了一个 warning，报告 id3 被截断
如果是在传统的 SQLMode（第 16 章将会详细介绍 SQLMode）下，这条记录是无法插入的


（5）将 id1、id2、id3 字段的精度和标度全部去掉，再次插入数据 1.23
mysql> desc t1;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id1   | float(5,2)   | YES  |     | NULL    |       |
| id2   | double(5,2)  | YES  |     | NULL    |       |
| id3   | decimal(5,2) | YES  |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
3 rows in set (0.00 sec)

mysql> alter table t1 modify id1 float;
Query OK, 0 rows affected (0.00 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> alter table t1 modify id2 double;
Query OK, 0 rows affected (0.00 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> alter table t1 modify id3 decimal;
Query OK, 3 rows affected, 3 warnings (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 3

mysql> desc t1;
+-------+---------------+------+-----+---------+-------+
| Field | Type          | Null | Key | Default | Extra |
+-------+---------------+------+-----+---------+-------+
| id1   | float         | YES  |     | NULL    |       |
| id2   | double        | YES  |     | NULL    |       |
| id3   | decimal(10,0) | YES  |     | NULL    |       |
+-------+---------------+------+-----+---------+-------+
3 rows in set (0.00 sec)


再次插入数据测试:
mysql> select * from t1;
+------+------+------+
| id1  | id2  | id3  |
+------+------+------+
| 1.23 | 1.23 |    1 |
| 1.23 | 1.23 |    1 |
| 1.23 | 1.23 |    1 |
+------+------+------+
3 rows in set (0.00 sec)

mysql> insert into t1 values(1.234, 1.234, 1.234);
Query OK, 1 row affected, 1 warning (0.00 sec)

mysql> show warnings;
+-------+------+------------------------------------------+
| Level | Code | Message                                  |
+-------+------+------------------------------------------+
| Note  | 1265 | Data truncated for column 'id3' at row 1 |
+-------+------+------------------------------------------+
1 row in set (0.00 sec)

mysql> select * from t1;                          
+-------+-------+------+
| id1   | id2   | id3  |
+-------+-------+------+
|  1.23 |  1.23 |    1 |
|  1.23 |  1.23 |    1 |
|  1.23 |  1.23 |    1 |
| 1.234 | 1.234 |    1 |
+-------+-------+------+
4 rows in set (0.00 sec)


这个时候，可以发现 id1、id2 字段中可以正常插入数据，而 id3 字段的小数位被截断。
上面这个例子验证了上面提到的浮点数如果不写精度和标度，则会按照实际精度值显示，
如果有精度和标度，则会自动将四舍五入后的结果插入，系统不会报错；

定点数如果不写精度和标度，则按照默认值 decimal(10,0)来进行操作，并且如果数据超越了精度和标度值，系统
则会报错


对于 BIT（位）类型，用于存放位字段值，BIT(M)可以用来存放多位二进制数，M 范围从 1～64，如果不写则默认为 1 位
对于位字段，直接使用 SELECT 命令将不会看到结果，可以用bin()（显示为二进制格式）或者 hex()（显示为十六进制格式）函数进行读取

下面的例子中，对测试表 t2 中的 bit 类型字段 id 做 insert 和 select 操作，这里重点观察一下
select 的结果：

mysql> use test1;
Database changed

mysql> create table t2(id bit); 
Query OK, 0 rows affected (0.03 sec)

mysql> desc t2;
+-------+--------+------+-----+---------+-------+
| Field | Type   | Null | Key | Default | Extra |
+-------+--------+------+-----+---------+-------+
| id    | bit(1) | YES  |     | NULL    |       |
+-------+--------+------+-----+---------+-------+
1 row in set (0.00 sec)

mysql> insert into t2 values(1); 
Query OK, 1 row affected (0.01 sec)

mysql> select * from t2;
+------+
| id   |
+------+
|     |
+------+
1 row in set (0.00 sec)


可以发现,直接 select * 结果为 NULL。改用 bin()和 hex()函数再试试:


mysql> select bin(id),hex(id) from t2; 
+---------+---------+
| bin(id) | hex(id) |
+---------+---------+
| 1       | 1       |
+---------+---------+
1 row in set (0.00 sec)


结果可以正常显示为二进制数字和十六进制数字

数据插入 bit 类型字段时,首先将数据转换为二进制,如果位数允许,将成功插入;如果位数小于 实际定义的位数,则插入失败

下面的例子中,在 t2 表插入数字 2,因为它的二进制码是 “10”,而 id 的定义是 bit(1),将无法进行插入:
mysql> desc t2;
+-------+--------+------+-----+---------+-------+
| Field | Type   | Null | Key | Default | Extra |
+-------+--------+------+-----+---------+-------+
| id    | bit(1) | YES  |     | NULL    |       |
+-------+--------+------+-----+---------+-------+
1 row in set (0.00 sec)

mysql> insert into t2 values(2);
ERROR 1406 (22001): Data too long for column 'id' at row 1
mysql> 
mysql> show warnings;
+-------+------+----------------------------------------+
| Level | Code | Message                                |
+-------+------+----------------------------------------+
| Error | 1406 | Data too long for column 'id' at row 1 |
+-------+------+----------------------------------------+
1 row in set (0.00 sec)

将 ID 定义修改为 bit(2)后,重新插入,插入成功:

mysql> alter table t2 modify id bit(2);
Query OK, 1 row affected (0.03 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql> desc t2;
+-------+--------+------+-----+---------+-------+
| Field | Type   | Null | Key | Default | Extra |
+-------+--------+------+-----+---------+-------+
| id    | bit(2) | YES  |     | NULL    |       |
+-------+--------+------+-----+---------+-------+
1 row in set (0.00 sec)

mysql> insert into t2 values(2);
Query OK, 1 row affected (0.01 sec)

mysql> select bin(id) from t2;
+---------+
| bin(id) |
+---------+
| 1       |
| 10      |
+---------+
2 rows in set (0.00 sec)


mysql> select bin(id),hex(id) from t2;
+---------+---------+
| bin(id) | hex(id) |
+---------+---------+
| 1       | 1       |
| 10      | 2       |
+---------+---------+
2 rows in set (0.01 sec)




3.2 日期时间类型
MySQL 中有多种数据类型可以用于日期和时间的表示,不同的版本可能有所差异
表 3-2 中 列出了 MySQL 5.0 中所支持的日期和时间类型。

表 3-2 MySQL 中的日期和时间类型
日期和时间类型  字节  最小值                  最大值
DATE            4     1000-01-01              9999-12-31
DATETIME        8     1000-01-01 00:00:00     9999-12-31 23:59:59
TIMESTAMP       4     19700101080001          2038 年的某个时刻
TIME            3     -838:59:59              838:59:59
YEAR            1     1901                    2155


这些数据类型的主要区别如下:
 如果要用来表示年月日,通常用 DATE 来表示
 如果要用来表示年月日时分秒,通常用 DATETIME 表示
 如果只用来表示时分秒,通常用 TIME 来表示
 如果需要经常插入或者更新日期为当前系统时间,则通常使用 TIMESTAMP 来表示
      1.TIMESTAMP 值返回后显示为“YYYY-MM-DD HH:MM:SS”格式的字符串,显示宽度固定为19 个字符
      2.如果想要获得数字值,应在 TIMESTAMP 列添加+0
 如果只是表示年份,可以用 YEAR 来表示,它比 DATE 占用更少的空间
      1.YEAR 有 2 位或 4 位格式的年。默认是 4 位格式
      2.在 4 位格式中,允许的值是 1901~2155 和 0000
      3.在 2 位格式中,允许的值是 70~69,表示从 1970~2069 年
      4.MySQL 以 YYYY 格式显示 YEAR值

从表 3-2 中可以看出:
    每种日期时间类型都有一个有效值范围,如果超出这个范围,在默认的 SQLMode 下,系统会进行错误提示,并将以零值来进行存储。     不同日期类型零值的 表示如表 3-3 所示:

    表 3-3 MySQL 中日期和时间类型的零值表示
    数据类型     零值表示
    DATETIME     0000-00-00 00:00:00
    DATE         0000-00-00
    TIMESTAMP    00000000000000
    TIME         00:00:00
    YEAR         0000


DATE、TIME 和 DATETIME 是最常使用的 3 种日期类型,以下例子在 3 种类型字段插入了相同的日期值,来看看它们的显示结果:

首先创建表 t,字段分别为 date、time、datetime 三种日期类型:
mysql> use test1;
Database changed

mysql> create table t(d date, t time, dt datetime);
Query OK, 0 rows affected (0.02 sec)

mysql> desc t;
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| d     | date     | YES  |     | NULL    |       |
| t     | time     | YES  |     | NULL    |       |
| dt    | datetime | YES  |     | NULL    |       |
+-------+----------+------+-----+---------+-------+
3 rows in set (0.00 sec)

用 now()函数插入当前日期:
mysql> insert into t values(now(), now(), now());
Query OK, 1 row affected, 1 warning (0.00 sec)


查看结果:
mysql> select * from t;
+------------+----------+---------------------+
| d          | t        | dt                  |
+------------+----------+---------------------+
| 2017-01-05 | 21:27:52 | 2017-01-05 21:27:52 |
+------------+----------+---------------------+
1 row in set (0.00 sec)


显而易见,DATETIME是DATE和TIME的组合,用户可以根据不同的需要,来选择不同的日期或时间类型以满足不同的应用。

TIMESTAMP也用来表示日期,但是和DATETIME有所不同,后面的章节中会专门介绍。下例对TIMESTAMP类型的特性进行一些测试。
创建测试表t,字段id1为TIMESTAMP类型:
mysql> use test1;
Database changed

mysql> alter table t rename time_test;
Query OK, 0 rows affected (0.01 sec)

mysql> show tables;
+-----------------+
| Tables_in_test1 |
+-----------------+
| A1              |
| A2              |
| A3              |
| dept            |
| emp             |
| t1              |
| t2              |
| time_test       |
+-----------------+
8 rows in set (0.00 sec)

mysql> create table t(id1 timestamp);
Query OK, 0 rows affected (0.03 sec)

mysql> desc t;
+-------+-----------+------+-----+---------+-------+
| Field | Type      | Null | Key | Default | Extra |
+-------+-----------+------+-----+---------+-------+
| id1   | timestamp | YES  |     | NULL    |       |
+-------+-----------+------+-----+---------+-------+
1 row in set (0.00 sec)

可以发现,系统给 tm 自动创建了默认值 CURRENT_TIMESTAMP(系统日期)
经测试发现Default默认值为NULL


插入一个 NULL 值试试:
mysql> insert into t values(null);
Query OK, 1 row affected (0.00 sec)

mysql> select * from t;
+------+
| id1  |
+------+
| NULL |
+------+
1 row in set (0.01 sec)


果然,t中正确插入了系统日期。注意,MySQL只给表中的第一个TIMESTAMP字段设置 默认值为系统日期,如果有第二个TIMESTAMP类型,则默认值设置为0值,测试如下:
经测试发现都是null

mysql> alter table t add id2 timestamp;
Query OK, 0 rows affected (0.06 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> desc t;
+-------+-----------+------+-----+---------+-------+
| Field | Type      | Null | Key | Default | Extra |
+-------+-----------+------+-----+---------+-------+
| id1   | timestamp | YES  |     | NULL    |       |
| id2   | timestamp | YES  |     | NULL    |       |
+-------+-----------+------+-----+---------+-------+
2 rows in set (0.00 sec)

即使将timestamp类型的默认值改成CURRENT_TIMESTAMP,插入值时，也会显示null
mysql> alter table t modify id1 timestamp default current_timestamp;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> alter table t modify id2 timestamp default current_timestamp;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> desc t;
+-------+-----------+------+-----+-------------------+-------+
| Field | Type      | Null | Key | Default           | Extra |
+-------+-----------+------+-----+-------------------+-------+
| id1   | timestamp | YES  |     | CURRENT_TIMESTAMP |       |
| id2   | timestamp | YES  |     | CURRENT_TIMESTAMP |       |
+-------+-----------+------+-----+-------------------+-------+
2 rows in set (0.00 sec)

mysql> insert into t values(null,null);
Query OK, 1 row affected (0.01 sec)

mysql> select * from t;
+------+------+
| id1  | id2  |
+------+------+
| NULL | NULL |
+------+------+
1 row in set (0.00 sec)

mysql> insert into t values('2017-01-01 10:10:10',null);
Query OK, 1 row affected (0.01 sec)

mysql> select * from t;
+---------------------+------+
| id1                 | id2  |
+---------------------+------+
| NULL                | NULL |
| 2017-01-01 10:10:10 | NULL |
+---------------------+------+
2 rows in set (0.01 sec)




TIMESTAMP还有一个重要特点,就是和时区相关:
当插入日期时,会先转换为本地时区后存放;而从数据库里面取出时,也同样需要将日期转换为本地时区后显示
这样,两个不同时区的用户看到的同一个日期可能是不一样的

下面的例子演示了这个差别:

(1)创建表t8,包含字段id1(TIMESTAMP)和id2(DATETIME),设置id2的目的是为了和id1做对比:
mysql> use test1;
Database changed
mysql> create table t8(id1 timestamp not null default current_timestamp, id2 datetime default null);
Query OK, 0 rows affected (0.02 sec)

mysql> desc t8;
+-------+-----------+------+-----+-------------------+-------+
| Field | Type      | Null | Key | Default           | Extra |
+-------+-----------+------+-----+-------------------+-------+
| id1   | timestamp | NO   |     | CURRENT_TIMESTAMP |       |
| id2   | datetime  | YES  |     | NULL              |       |
+-------+-----------+------+-----+-------------------+-------+
2 rows in set (0.00 sec)


(2)查看当前时区:
mysql> show variables like 'time_zone';
+---------------+--------+
| Variable_name | Value  |
+---------------+--------+
| time_zone     | SYSTEM |
+---------------+--------+
1 row in set (0.00 sec)

mysql> system date
Thu Jan  5 22:27:04 HKT 2017
可以发现,时区的值为“SYSTEM”,这个值默认是和主机的时区值一致的,因为我们本机是HK时区, 这里的“SYSTEM”实际是东八区(+8:00)


(3)用 now()函数插入当前日期:
mysql> insert into t8 values(now(),now());
Query OK, 1 row affected (0.01 sec)

mysql> select * from t8;
+---------------------+---------------------+
| id1                 | id2                 |
+---------------------+---------------------+
| 2017-01-05 22:25:19 | 2017-01-05 22:25:19 |
+---------------------+---------------------+
1 row in set (0.00 sec)

结果显示 id1 和 id2 的值完全相同


(4)修改mysql数据库的时区为东九区,再次查看表中日期:
mysql> set time_zone='+9:00';          
Query OK, 0 rows affected (0.00 sec)

mysql> show variables like 'time_zone';
+---------------+--------+
| Variable_name | Value  |
+---------------+--------+
| time_zone     | +09:00 |
+---------------+--------+
1 row in set (0.01 sec)

mysql> select * from t8;               
+---------------------+---------------------+
| id1                 | id2                 |
+---------------------+---------------------+
| 2017-01-05 23:25:19 | 2017-01-05 22:25:19 |
+---------------------+---------------------+
1 row in set (0.00 sec)


结果中可以发现,id1 的值比 id2 的值快了 1 个小时,也就是说,东九区的人看到的“2017-01-05 23:25:19”是当地时区的实际日期,也就是东八区的“2017-01-05 22:25:19”,如果还是以 “2017-01-05 22:25:19”理解时间必然导致误差


TIMESTAMP的取值范围为19700101080001到2038年的某一天,因此它不适合存放比较久远的日期,下面简单测试一些这个范围:
mysql> use test1;
Database changed
mysql> desc t;
+-------+-----------+------+-----+-------------------+-------+
| Field | Type      | Null | Key | Default           | Extra |
+-------+-----------+------+-----+-------------------+-------+
| id1   | timestamp | YES  |     | CURRENT_TIMESTAMP |       |
| id2   | timestamp | YES  |     | CURRENT_TIMESTAMP |       |
+-------+-----------+------+-----+-------------------+-------+
2 rows in set (0.00 sec)


mysql> alter table t drop id2;  
Query OK, 0 rows affected (0.06 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> desc t;
+-------+-----------+------+-----+-------------------+-------+
| Field | Type      | Null | Key | Default           | Extra |
+-------+-----------+------+-----+-------------------+-------+
| id1   | timestamp | YES  |     | CURRENT_TIMESTAMP |       |
+-------+-----------+------+-----+-------------------+-------+
1 row in set (0.00 sec)

mysql> delete from t;
Query OK, 3 rows affected (0.01 sec)

mysql> select * from t;
Empty set (0.00 sec)

mysql> insert into t values(19700101080001);
Query OK, 1 row affected (0.01 sec)

mysql> select * from t;                     
+---------------------+
| id1                 |
+---------------------+
| 1970-01-01 08:00:01 |
+---------------------+
1 row in set (0.00 sec)



mysql> insert into t values(19700101080000);
ERROR 1292 (22007): Incorrect datetime value: '19700101080000' for column 'id1' at row 1
mysql> 
mysql> show warnings;                       
+-------+------+----------------------------------------------------------------------+
| Level | Code | Message                                                              |
+-------+------+----------------------------------------------------------------------+
| Error | 1292 | Incorrect datetime value: '19700101080000' for column 'id1' at row 1 |
+-------+------+----------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> select * from t;
+---------------------+
| id1                 |
+---------------------+
| 1970-01-01 08:00:01 |
+---------------------+
1 row in set (0.00 sec)


其中 19700101080000 超出了 tm 的下限,系统出现警告提示。查询一下,发现插入值变成 了 0 值。
将测试发现，提示时间日期不正确，数据无法插入到表



再来测试一下 TIMESTAMP 的上限值:
mysql> insert into t values('2038-01-19 11:14:07');
Query OK, 1 row affected (0.01 sec)

mysql> select * from t;                            
+---------------------+
| id1                 |
+---------------------+
| 1970-01-01 08:00:01 |
| 1970-01-01 08:00:01 |
| 1970-01-01 08:00:02 |
| 2038-01-19 11:14:07 |
+---------------------+
4 rows in set (0.00 sec)

mysql> insert into t values('2038-01-19 11:14:08');
ERROR 1292 (22007): Incorrect datetime value: '2038-01-19 11:14:08' for column 'id1' at row 1


从上面例子可以看出,TIMESTAMP和DATETIME的表示方法非常类似,区别主要有以下几点:
 1.TIMESTAMP支持的时间范围较小,其取值范围从19700101080001到2038年的某个时间,而DATETIME是从1000-01-01 00:00:00到9999-12-31 23:59:59,范围更大。

 2.表中的第一个TIMESTAMP列自动设置为系统时间。如果在一个TIMESTAMP列中插入 NULL,则该列值将自动设置为当前的日期和时间。在插入或更新一行但不明确给 TIMESTAMP列赋值时也会自动设置该列的值为当前的日期和时间,当插入的值超出 取值范围时,MySQL认为该值溢出,使用“0000-00-00 00:00:00”进行填补。

  3.TIMESTAMP的插入和查询都受当地时区的影响,更能反应出实际的日期。而 DATETIME则只能反应出插入时当地的时区,其他时区的人查看数据必然会有误差的

  4.TIMESTAMP的属性受MySQL版本和服务器SQLMode的影响很大,本章都是以MySQL 5.0为例进行介绍,在不同的版本下可以参考相应的MySQL帮助文档


YEAR 类型主要用来表示年份,当应用只需要记录年份时,用 YEAR 比 DATE 将更节省空间
下面的例子在表 t 中定义了一个 YEAR 类型字段,并插入一条记录:
mysql> use test1;
Database changed
mysql> create table y(y year);
Query OK, 0 rows affected (0.02 sec)

mysql> desc y;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| y     | year(4) | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
1 row in set (0.00 sec)

mysql> select * from y;
+------+
| y    |
+------+
| 2100 |
+------+
1 row in set (0.00 sec)


MySQL 以 YYYY 格式检索和显示 YEAR 值,范围是1901~2155。当使用两位字符串表示 年份时,其范围为“00”到“99”
 1.“00”到“69”范围的值被转换为 2000~2069 范围的 YEAR 值
  2.“70”到“99”范围的值被转换为 1970~1999 范围的 YEAR 值。

细心的读者可能发现,在上面的例子中,日期类型的插入格式有很多,包括整数(如 2100)、字符串(如 2038-01-19 11:14:08)、函数(如 NOW())等,大家可能会感到疑惑,到底什么样的格式才能够正确地插入到对应的日期字段中呢?

下面以 DATETIME 为例进行介绍:
 YYYY-MM-DD HH:MM:SS 或 YY-MM-DD HH:MM:SS 格式的字符串
  允许“不严格” 语法:任何标点符都可以用做日期部分或时间部分之间的间割符:
  例如,“98-12-31 11:30:45”、“98.12.31 11+30+45”、“98/12/31 11*30*45”和“98@12@31 11^30^45” 是等价的
  对于包括日期部分间割符的字符串值,如果日和月的值小于10,不需要指定两位数
  “1979-6-9”与“1979-06-09”是相同的。

  同样,对于包括时间部分间割符的字符串值,如果时、分和秒的值小于10,不需要指定两位数:
  “1979-10-30 1:2:3”与“1979-10-30 01:02:03”相同
 YYYYMMDDHHMMSS 或 YYMMDDHHMMSS 格式的没有间割符的字符串,假定字符串对于日期类型是有意义的。
  例如,“19970523091528”和“970523091528”被解 释为“1997-05-23 09:15:28”,
  但“971122129015”是不合法的(它有一个没有意 义的分钟部分),将变为“0000-00-00 00:00:00”

 YYYYMMDDHHMMSS 或 YYMMDDHHMMSS 格式的数字,假定数字对于日期类型是有意义的:
  例如,19830905132800 和 830905132800 被解释为“1983-09-05 13:28:00”
  数字值应为 6、8、12 或者 14 位长。
  如果一个数值是 8 或 14 位长,则假定为 YYYYMMDD 或 YYYYMMDDHHMMSS 格式,前 4 位数表示年
  如果数字 是 6 或 12 位长,则假定为 YYMMDD 或 YYMMDDHHMMSS 格式,前 2 位数表示年
  其他数字 被解释为仿佛用零填充到了最近的长度。
 
  函数返回的结果,其值适合 DATETIME、DATE 或者 TIMESTAMP 上下文,例如 NOW() 或 CURRENT_DATE。
  对于其他数据类型,其使用原则与上面的内容类似,限于篇幅,这里就不再赘述。
  最后通过一个例子,说明如何采用不同的格式将日期“2007-9-3 12:10:10”插入到 DATETIME 列中:


mysql> use test1;
Database changed
mysql> create table t6(dt datetime);
Query OK, 0 rows affected (0.02 sec)

mysql> desc t6;
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| dt    | datetime | YES  |     | NULL    |       |
+-------+----------+------+-----+---------+-------+
1 row in set (0.00 sec)

mysql> insert into t6 values('2017-01-05 23:59:59');
Query OK, 1 row affected (0.00 sec)

mysql> insert into t6 values('2017/01/05 23+59+59');  
Query OK, 1 row affected (0.01 sec)

mysql> insert into t6 values('20170105235959');     
Query OK, 1 row affected (0.00 sec)

mysql> insert into t6 values(20170105235959);  
Query OK, 1 row affected (0.00 sec)

mysql> select * from t6;
+---------------------+
| dt                  |
+---------------------+
| 2017-01-05 23:59:59 |
| 2017-01-05 23:59:59 |
| 2017-01-05 23:59:59 |
| 2017-01-05 23:59:59 |
+---------------------+
4 rows in set (0.00 sec)
